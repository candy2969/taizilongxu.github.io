<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>Hackerxu's Blog</title>
    <subtitle>Python,HTML,CSS,Machine Leaning</subtitle>
    <link href="http://hackerxu.com/atom.xml" rel="self"/>
    <link href="http://hackerxu.com"/>
    <updated>2014-11-14T10:41:35+08:00</updated>
    <id>http://hackerxu.com</id>
    <author>
        <name>xuxiao</name>
    </author>
    
    <entry>
        <title>粒子群算法(转)</title>
        <link href="http://hackerxu.com/2014/11/14/PSO.html"/>
        <updated>2014-11-14T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/14/PSO</id>
        <content type="html">&lt;p&gt;本文整理自: &lt;a href=&quot;http://blog.csdn.net/niuyongjie/article/details/1569671&quot;&gt;http://blog.csdn.net/niuyongjie/article/details/1569671&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;粒子群算法简介&lt;/h1&gt;

&lt;h2&gt;1 粒子群算法的历史&lt;/h2&gt;

&lt;p&gt;粒子群算法源于复杂适应系统（Complex Adaptive System,CAS）。CAS理论于1994年正式提出，CAS中的成员称为主体。比如研究鸟群系统，每个鸟在这个系统中就称为主体。主体有适应性，它能够与环境及其他的主体进行交流，并且根据交流的过程“学习”或“积累经验”改变自身结构与行为。整个系统的演变或进化包括：新层次的产生（小鸟的出生）；分化和多样性的出现（鸟群中的鸟分成许多小的群）；新的主题的出现（鸟寻找食物过程中，不断发现新的食物）。&lt;/p&gt;

&lt;p&gt;所以CAS系统中的主体具有4个基本特点（这些特点是粒子群算法发展变化的依据）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，主体是主动的、活动的。&lt;/li&gt;
&lt;li&gt;主体与环境及其他主体是相互影响、相互作用的，这种影响是系统发展变化的主要动力。&lt;/li&gt;
&lt;li&gt;环境的影响是宏观的，主体之间的影响是微观的，宏观与微观要有机结合。&lt;/li&gt;
&lt;li&gt;最后，整个系统可能还要受一些随机因素的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粒子群算法就是对一个CAS系统－－－鸟群社会系统的研究得出的。&lt;/p&gt;

&lt;p&gt;粒子群算法（ Particle Swarm Optimization, PSO）最早是由Eberhart和Kennedy于1995年提出，它的基本概念源于对鸟群觅食行为的研究。设想这样一个场景:一群鸟在随机搜寻食物，在这个区域里只有一块食物，所有的鸟都不知道食物在哪里，但是它们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢?最简单有效的就是搜寻目前离食物最近的鸟的周围区域。&lt;/p&gt;

&lt;p&gt;PSO算法就从这种生物种群行为特性中得到启发并用于求解优化问题。在PSO中，每个优化问题的潜在解都可以想象成d维搜索空间上的一个点，我们称之为“粒子”（Particle），所有的粒子都有一个被目标函数决定的适应值(Fitness Value )，每个粒子还有一个速度决定他们飞翔的方向和距离，然后粒子们就追随当前的最优粒子在解空间中搜索。Reynolds对鸟群飞行的研究发现。鸟仅仅是追踪它有限数量的邻居但最终的整体结果是整个鸟群好像在一个中心的控制之下.即复杂的全局行为是由简单规则的相互作用引起的。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的具体表述&lt;/h2&gt;

&lt;p&gt;上面罗嗦了半天，那些都是科研工作者写论文的语气，不过，PSO的历史就像上面说的那样。下面通俗的解释PSO算法。&lt;/p&gt;

&lt;p&gt;PSO算法就是模拟一群鸟寻找食物的过程，每个鸟就是PSO中的粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，不停改变自己在空中飞行的位置与速度。大家也可以观察一下，鸟群在寻找食物的过程中，开始鸟群比较分散，逐渐这些鸟就会聚成一群，这个群忽高忽低、忽左忽右，直到最后找到食物。这个过程我们转化为一个数学问题。寻找函数&lt;code&gt;y=1-cos(3*x)*exp(-x)&lt;/code&gt;的在[0,4]最大值。该函数的图形如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_hanshutuxing.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;当x=0.9350-0.9450，达到最大值y=1.3706。为了得到该函数的最大值，我们在[0，4]之间随机的洒一些点，为了演示，我们放置两个点，并且计算这两个点的函数值，同时给这两个点设置在[0，4]之间的一个速度。下面这些点就会按照一定的公式更改自己的位置，到达新位置后，再计算这两个点的值，然后再按照一定的公式更新自己的位置。直到最后在y=1.3706这个点停止自己的更新。这个过程与粒子群算法作为对照如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这两个点就是粒子群算法中的粒子。&lt;/li&gt;
&lt;li&gt;该函数的最大值就是鸟群中的食物 &lt;/li&gt;
&lt;li&gt;计算两个点函数值就是粒子群算法中的适应值，计算用的函数就是粒子群算法中的适应度函数。&lt;/li&gt;
&lt;li&gt;更新自己位置的一定公式就是粒子群算法中的位置速度更新公式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面演示一下这个算法运行一次的大概过程：&lt;/p&gt;

&lt;p&gt;第一次初始化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi1.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi2.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi3.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第21次更新:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi4.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后的结果（30次迭代）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi5.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后所有的点都集中在最大值的地方。&lt;/p&gt;

&lt;p&gt;呵呵，现在粒子群算法的大概思想就说到这里。下节介绍标准的粒子群算法.&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法&lt;/h1&gt;

&lt;p&gt;在上一节的叙述中，唯一没有给大家介绍的就是函数的这些随机的点（粒子）是如何运动的，只是说按照一定的公式更新。这个公式就是粒子群算法中的位置速度更新公式。下面就介绍这个公式是什么。在上一节中我们求取函数y=1-cos(3*x)*exp(-x)的在[0,4]最大值。并在[0,4]之间放置了两个随机的点，这些点的坐标假设为x1=1.5； x2=2.5；这里的点是一个标量，但是我们经常遇到的问题可能是更一般的情况－－x为一个矢量的情况，比如二维的情况 z=2*x1+3*x22的情况。这个时候我们的每个粒子为二维，记粒子P1＝(x11,x12),P2=(x21,x22),P3=(x31,x32)，......Pn=(xn1,xn2)。这里n为粒子群群体的规模，也就是这个群中粒子的个数，每个粒子的维数为2。更一般的是粒子的维数为q，这样在这个种群中有n个粒子，每个粒子为q 维。&lt;/p&gt;

&lt;p&gt;由n个粒子组成的群体对Q维（就是每个粒子的维数）空间进行搜索。每个粒子表示为：xi＝（xi1,xi2,xi3,...,xiQ），每个粒子对应的速度可以表示为vi=(vi1,vi2,vi3,....,viQ)，每个粒子在搜索时要考虑两个因素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自己搜索到的历史最优值 pi ，pi=(pi1,pi2,....,piQ)，i=1,2,3,....,n。&lt;/li&gt;
&lt;li&gt;全部粒子搜索到的最优值pg，pg=(pg1,pg2,....,pgQ)，注意这里的pg只有一个。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面给出粒子群算法的位置速度更新公式：&lt;/p&gt;

&lt;p&gt;$$v_{id}^{k+1} = wv_{id}^{k} + c_1\xi(p_{id}^k - x_{id}^k) + c_2\eta(p_{gd}^{k} - x_{id}^k)$$&lt;/p&gt;

&lt;p&gt;$$x_{id}^{k+1} = x_{id}^{k} + rv_{id}^{k+1}$$&lt;/p&gt;

&lt;p&gt;这里有几个重要的参数需要大家记忆，因为在以后的讲解中将会经常用到,它们是：&lt;/p&gt;

&lt;p&gt;$w$是保持原来速度的系数，所以叫做&lt;strong&gt;惯性权重&lt;/strong&gt;。
$c_1$是粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，所以叫“&lt;strong&gt;认知&lt;/strong&gt;”。通常设置为2。
$\xi$  $\eta$是[0,1]区间内均匀分布的随机数。
$r$是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做&lt;strong&gt;约束因子&lt;/strong&gt;。通常设置为1。&lt;/p&gt;

&lt;p&gt;这样一个标准的粒子群算法就结束了。&lt;/p&gt;

&lt;p&gt;下面对整个基本的粒子群的过程给一个简单的图形表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_liucheng.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;判断终止条件可是设置适应值到达一定的数值或者循环一定的次数。&lt;/p&gt;

&lt;p&gt;注意：这里的粒子是同时跟踪自己的历史最优值与全局（群体）最优值来改变自己的位置预速度的，所以又叫做&lt;strong&gt;全局版本的标准粒子群优化算法&lt;/strong&gt;。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>草帽星系</title>
        <link href="http://hackerxu.com/2014/10/26/habo.html"/>
        <updated>2014-10-26T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/26/habo</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/900x600_A9FVD2A84T8F0001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;渺小的人类&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>数据挖掘之Apriori算法</title>
        <link href="http://hackerxu.com/2014/10/18/apriori.html"/>
        <updated>2014-10-18T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/18/apriori</id>
        <content type="html">&lt;p&gt;关联规则挖掘（Association rule mining）是数据挖掘中最活跃的研究方法之一，可以用来发现事情之间的联系，最早是为了发现超市交易数据库中不同的商品之间的关系。(啤酒与尿布)&lt;/p&gt;

&lt;h4&gt;基本概念&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;支持度的定义：support(X--&amp;gt;Y) = |X交Y|/N=集合X与集合Y中的项在一条记录中同时出现的次数/数据记录的个数。例如：support({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/数据记录数 = 3/5=60%。&lt;/li&gt;
&lt;li&gt;自信度的定义：confidence(X--&amp;gt;Y) = |X交Y|/|X| = 集合X与集合Y中的项在一条记录中同时出现的次数/集合X出现的个数 。例如：confidence({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/啤酒出现的次数=3/3=100%;confidence({尿布}--&amp;gt;{啤酒}) = 啤酒和尿布同时出现的次数/尿布出现的次数 = 3/4 = 75%&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作&lt;strong&gt;强规则&lt;/strong&gt; ,如果项集满足最小支持度,则称它为&lt;strong&gt;频繁项集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“如何由大型数据库挖掘关联规则?”关联规则的挖掘是一个两步的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找出所有频繁项集:根据定义,这些项集出现的频繁性至少和预定义的最小支持计数一样。&lt;/li&gt;
&lt;li&gt;由频繁项集产生强关联规则:根据定义,这些规则必须满足最小支持度和最小置信度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apriori定律&lt;/p&gt;

&lt;p&gt;为了减少频繁项集的生成时间，我们应该尽早的消除一些完全不可能是频繁项集的集合，Apriori的两条定律就是干这事的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律1&lt;/strong&gt;：如果一个集合是频繁项集，则它的所有子集都是频繁项集。举例：假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律2&lt;/strong&gt;：如果一个集合不是频繁项集，则它的所有超集都不是频繁项集。举例：假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/31160727-a7d9a4d0a64a4f4b83a831980273450d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面的图演示了Apriori算法的过程，注意看由二级频繁项集生成三级候选项集时，没有{牛奶,面包,啤酒}，那是因为{面包,啤酒}不是二级频繁项集，这里利用了Apriori定理。最后生成三级频繁项集后，没有更高一级的候选项集，因此整个算法结束，{牛奶,面包,尿布}是最大频繁子集。&lt;/p&gt;

&lt;p&gt;Python实现算法地址&lt;a href=&quot;https://github.com/taizilongxu/datamining&quot;&gt;https://github.com/taizilongxu/datamining&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&quot;&gt;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lizhengnanhua/article/details/9061887&quot;&gt;http://blog.csdn.net/lizhengnanhua/article/details/9061887&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>Python subprocess模块总结</title>
        <link href="http://hackerxu.com/2014/10/09/subprocess.html"/>
        <updated>2014-10-09T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/09/subprocess</id>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;subprocess意在替代其他几个老的模块或者函数，比如：os.system os.spawn* os.popen* popen2.* commands.*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;subprocess最简单的用法就是调用shell命令了,另外也可以调用程序,并且可以通过stdout,stdin和stderr进行交互&lt;/p&gt;

&lt;h4&gt;subprocess的主类&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;bufsize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;executable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;close_fds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;universal_newlines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;startupinfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;creationflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;args可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。&lt;/li&gt;
&lt;li&gt;bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲)&lt;/li&gt;
&lt;li&gt;stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。&lt;/li&gt;
&lt;li&gt;preexec_fn只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。&lt;/li&gt;
&lt;li&gt;Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。&lt;/li&gt;
&lt;li&gt;shell设为true，程序将通过shell来执行。&lt;/li&gt;
&lt;li&gt;cwd用于设置子进程的当前目录&lt;/li&gt;
&lt;li&gt;env是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。&lt;/li&gt;
&lt;li&gt;Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用&amp;#39;/r/n&amp;#39;表示换，而Linux下用&amp;#39;/n&amp;#39;。如果将此参数设置为True，Python统一把这些换行符当作&amp;#39;/n&amp;#39;来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;li&gt;startupinfo与createionflags只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Popen方法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Popen.poll()：用于检查子进程是否已经结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.wait()：等待子进程结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.communicate(input=None)：与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。&lt;/li&gt;
&lt;li&gt;Popen.send_signal(signal)：向子进程发送信号。&lt;/li&gt;
&lt;li&gt;Popen.terminate()：停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。&lt;/li&gt;
&lt;li&gt;Popen.kill()：杀死子进程。&lt;/li&gt;
&lt;li&gt;Popen.stdin：如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stdout：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stderr：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.pid：获取子进程的进程ID。&lt;/li&gt;
&lt;li&gt;Popen.returncode：获取进程的返回值。如果进程还没有结束，返回None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;：运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。文章一开始的例子就演示了call函数。如果子进程不需要进行交互,就可以使用该函数来创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.check_call(*popenargs, **kwargs)&lt;/code&gt;：与&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;功能一样，只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常。在异常对象中，包括进程的returncode信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上全是抄的&lt;/p&gt;

&lt;h4&gt;在程序中运行其他程序或shell&lt;/h4&gt;

&lt;p&gt;可以这样写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.call(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者的区别是前者无阻塞,会和主程序并行运行,后者必须等待命令执行完毕,如果想要前者编程阻塞可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;s = subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
s.wait()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;程序返回运行结果&lt;/h4&gt;

&lt;p&gt;有时候我们需要程序的返回结果,可以这样做&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.Popen(&amp;#39;ls -l&amp;#39;, shell=True, stdout=subprocess.PIPE) 
&amp;gt;&amp;gt;&amp;gt; s.communicate() 
(&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;, None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会返回一个元组：(stdoutdata, stderrdata)&lt;/p&gt;

&lt;p&gt;subprocess还有另一种更简单方法,效果一样,它会返回stdout&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.check_output(&amp;#39;ls -l&amp;#39;, shell=True)
&amp;gt;&amp;gt;&amp;gt; s
&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前者可以实现更多的交互,如stderr和stdin,但是在前面调用Popen的时候要实现定义&lt;code&gt;Popen(stdin=subprocess.PIPE, stderr=subprocess)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;给子进程输入&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;vamei&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;()不为空，则写入subprocess.PIPE，为空，则从subprocess.PIPE读取&lt;/p&gt;

&lt;h4&gt;subprocess.PIPE&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ls&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;-l&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wc&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上是这样的过程&lt;/p&gt;

&lt;p&gt;child1.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdin&amp;lt;--subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;subprocess.PIPE实际上为文本流提供一个缓存区。直到communicate()方法从PIPE中读取出PIPE中的文本.要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/jgood/article/details/4498166&quot;&gt;http://blog.csdn.net/jgood/article/details/4498166&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&quot;&gt;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/imzoer/article/details/8678029&quot;&gt;http://blog.csdn.net/imzoer/article/details/8678029&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ipseek.blog.51cto.com/1041109/807513&quot;&gt;http://ipseek.blog.51cto.com/1041109/807513&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jb51.net/article/48086.htm&quot;&gt;http://www.jb51.net/article/48086.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    </entry>
    
    <entry>
        <title>把程序打包上传到PyPi版本库中</title>
        <link href="http://hackerxu.com/2014/10/08/Pypi.html"/>
        <updated>2014-10-08T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/08/Pypi</id>
        <content type="html">&lt;h4&gt;1 首先必须要按照以下文件结构&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban_token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;必须至少一个包,即上面的douban,把模块都放在包下,且包中必须有&lt;code&gt;__init__.py&lt;/code&gt;文件(可以为空)&lt;/li&gt;
&lt;li&gt;必须有一个setup.py文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;2 setup.py文件&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;setuptools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_packages&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;打包的用的setup必须引入&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0.2.0&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;README.md&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 文件名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 版本(每次更新上传Pypi需要修改)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a tiny and smart cli player of douban.fm based on Python&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 放README.md文件,方便在Pypi页展示&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;classifiers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keywords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;python douban douban.fm terminal&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关键字&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;taizilongxu&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 用户名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;468137306@qq.com&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 邮箱&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;https://github.com/taizilongxu/douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# github上的地址,别的地址也可以&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;license&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;MIT&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 遵循的协议&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 发布的包名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;include_package_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;zip_safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;install_requires&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;termcolor&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 满足的依赖&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry_points&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;console_scripts&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm = douban.douban:main&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; entry_points : [可执行程序名]=引入的包名.子包名.模块名:入口函数.这个要注意了,主程序要引入main函数进行执行.好让包找到执行的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3 安装&lt;/h4&gt;

&lt;p&gt;如果不上传文件,只在本机中安装,那么可以运行以下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就在本机安装了程序,在shell中输入douban.fm(刚才在entry_points中输入的可执行程序名),就可以执行了&lt;/p&gt;

&lt;h4&gt;4 上传到Pypi&lt;/h4&gt;

&lt;p&gt;先在 &lt;a href=&quot;https://pypi.python.org/pypi&quot;&gt;https://pypi.python.org/pypi&lt;/a&gt; 注册个Pypi号,认证邮箱.&lt;/p&gt;

&lt;p&gt;然后再在你的用户目录下新建一个&lt;code&gt;.pypirc&lt;/code&gt;文件,输入如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[distutils]
index-servers =
    pypi

[pypi]
username:
password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把username和password填上保存就可以了&lt;/p&gt;

&lt;p&gt;回到你的setup.py目录,输入如下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo python setup.py register sdist bdist_egg upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你的包就可以发到Pypi里了,通过pip或者easy_install就可以下载你的包了&lt;/p&gt;

&lt;h4&gt;5 更新Pypi包&lt;/h4&gt;

&lt;p&gt;当包版本更新后,需要在你的setup.py文件里修改VERSION,然后运行第4部的命令就可以了(如果不更新VERSION包就不能上传成功)&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>douban.fm 终端命令行豆瓣FM</title>
        <link href="http://hackerxu.com/2014/10/07/doubanfm.html"/>
        <updated>2014-10-07T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/07/doubanfm</id>
        <content type="html">&lt;h2&gt;douban.fm &lt;a href=&quot;https://pypi.python.org/pypi/douban.fm&quot;&gt;&lt;img src=&quot;https://pypip.in/version/douban.fm/badge.svg&quot; alt=&quot;version&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://pypi.python.org/pypi/douban.fm&quot;&gt;&lt;img src=&quot;https://pypip.in/download/douban.fm/badge.png&quot; alt=&quot;Downloads&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这个版本的命令行界面是参考了 Node.js版本的&lt;a href=&quot;https://github.com/turingou/douban.fm&quot;&gt;douban.fm&lt;/a&gt;制作的,向原作者致敬.终端界面设计的非常好看.&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://github.com/cloverstd&quot;&gt;Cloverstd&lt;/a&gt;的修改,已经支持Mac OS X(&amp;gt;=V0.2.9)&lt;/p&gt;

&lt;p&gt;PS:如果喜欢请加Star(&lt;em&gt;^__^&lt;/em&gt;)……&lt;/p&gt;

&lt;h3&gt;Screenshots&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/douban.fm/master/img/out.gif&quot; alt=&quot;screenshot&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Support&lt;/h3&gt;

&lt;p&gt;Linux/Mac OS X&lt;/p&gt;

&lt;h3&gt;Do something cool!&lt;/h3&gt;

&lt;p&gt;其实Node.js版本已经很好了,功能齐全,但是我发现在我的zsh + tmux环境下颜色竟然显示不出来,感觉很蛋疼.&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo pip install douban.fm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要mplayer播放器依赖,如未安装:&lt;/p&gt;

&lt;p&gt;Ubuntu:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo apt-get install mplayer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ brew install mplayer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Usage&lt;/h3&gt;

&lt;p&gt;在终端下直接输入&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ douban.fm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Login&lt;/h3&gt;

&lt;p&gt;第一次登陆需要输入账号,密码,程序不会保留密码,而是保存返回的token存储在~/.douban_token.txt,下次登陆无需输入密码.&lt;/p&gt;

&lt;h3&gt;Keys&lt;/h3&gt;

&lt;p&gt;支持vim按键&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;移动
 [j]     --&amp;gt; 下
 [k]     --&amp;gt; 上
 [g]     --&amp;gt; 移到最顶
 [G]     --&amp;gt; 移到最底
音乐
 [space] --&amp;gt; 播放
 [w]     --&amp;gt; 打开歌曲主页
 [n]     --&amp;gt; 下一首
 [r]     --&amp;gt; 喜欢/取消喜欢
 [b]     --&amp;gt; 不再播放
 [q]     --&amp;gt; 退出
 [p]     --&amp;gt; 暂停
 [l]     --&amp;gt; 单曲循环
音量(&amp;gt;=V0.2.9)
 [=]     --&amp;gt; 增
 [-]     --&amp;gt; 减
 [m]     --&amp;gt; 静音
歌词(&amp;gt;=v0.2.9)
 [o]     --&amp;gt; 显示歌词(Bug很多,先别用,没有反应就是没找到歌词)
 [q]     --&amp;gt; 退出歌词
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Configuration(&amp;gt;=v0.2.8)&lt;/h3&gt;

&lt;p&gt;.doubanfm_config保存在了~/.doubanfm_config,根据需要可以修改按键的映射&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[key]
UP = k       # 上
DOWN = j     # 下
TOP = g      # 顶
BOTTOM = G   # 底
OPENURL = w  # 打开歌曲主页
RATE = r     # 标记喜欢/取消喜欢
NEXT = n     # 下一首
BYE = b      # 不再播放
QUIT = q     # 退出
PAUSE = p    # 暂停
LOOP = l     # 单曲循环
MUTE = m     # 静音
LRC = o      # 歌词
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Done&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;登陆token&lt;/li&gt;
&lt;li&gt;显示PRO&lt;/li&gt;
&lt;li&gt;cli设计&lt;/li&gt;
&lt;li&gt;播放,下一首,红心,不再播放&lt;/li&gt;
&lt;li&gt;进度条(时间)&lt;/li&gt;
&lt;li&gt;终端高度的自动调整&lt;/li&gt;
&lt;li&gt;pro用户歌曲kbps的选择(pro用户会自动选择192kbps)&lt;/li&gt;
&lt;li&gt;歌曲结束request(发送歌曲完成)&lt;/li&gt;
&lt;li&gt;config设置&lt;/li&gt;
&lt;li&gt;调节音量(amixer) + 标题中显示音量&lt;/li&gt;
&lt;li&gt;歌词&lt;/li&gt;
&lt;li&gt;歌曲暂停&lt;/li&gt;
&lt;li&gt;单曲播放&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;TODO&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;默认频道&lt;/li&gt;
&lt;li&gt;播放歌曲数 红心数 不再播放数&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;BUG&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;播放歌曲中有时候会暂停&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;退出后终端光标会隐藏&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;.douban_token.txt路径问题&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;登陆异常处理&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;静音后播放下一首会取消静音&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Authors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Fansion&quot;&gt;Fansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cloverstd&quot;&gt;Cloverstd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.js版本的&lt;a href=&quot;https://github.com/turingou/douban.fm&quot;&gt;douban.fm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skyline75489/pyfm&quot;&gt;豆瓣FM命令行播放器(pyfm)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zonyitoo/doubanfm-qt/wiki/%E8%B1%86%E7%93%A3FM-API&quot;&gt;豆瓣电台 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Log&lt;/h3&gt;

&lt;p&gt;V0.2.11 config兼容问题&lt;/p&gt;

&lt;p&gt;V0.2.10 滚动歌词,单曲循环,暂停,静音&lt;/p&gt;

&lt;p&gt;V0.2.9 支持歌词,支持Mac OS X&lt;/p&gt;

&lt;p&gt;V0.2.8 增加config&lt;/p&gt;

&lt;h3&gt;License (MIT)&lt;/h3&gt;

&lt;p&gt;Copyright (c) 2014 hackerxu&lt;/p&gt;

&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &amp;quot;Software&amp;quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt;

&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt;

&lt;p&gt;THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Douban Fm 之多进程,多线程</title>
        <link href="http://hackerxu.com/2014/10/01/DoubanFm-threading.html"/>
        <updated>2014-10-01T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/01/DoubanFm-threading</id>
        <content type="html">&lt;p&gt;最近Python版本的Douban Fm制作接近尾声,不过困扰我的有一个最大的难题,那就是前台界面和后台程序的融合.&lt;/p&gt;

&lt;p&gt;在以前的编程中虽然语言是面向对象的,但程序的设计主旨一般都还是面向过程的,也就是说平常的程序设计中从来没考虑过进程,线程,以及他们之间的通信.虽然操作系统中对线程,进程都有所了解,但是一想到的是系统编程里的就望而却步了.这会终于好好的研究了一下进程编程,稍后会写笔记,先写写Douban Fm碰到的问题.&lt;/p&gt;

&lt;p&gt;没错,就是线程,进程的问题,当你设计一个cli样式的界面,而且还需要有进程在后端运行,那么你一定需要多线程或是多进程的.在Python里最最原始的方法有一个fork()方法,相信这个方法是从linux中继承过来的,不过这种方法既难掌握,又非常的混乱,比如我们有一个while循环的话,那么在其中的fork()就是一个灾难了.&lt;/p&gt;

&lt;p&gt;相对比较高级的一个方法是multiprocessing,这个函数可以创建一个进程,如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 注意函数没有括号&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数允许你创建一个进程,运行在主程序之外,当然可以和主程序进行一些交互.&lt;/p&gt;

&lt;p&gt;另外一个比较高级的方法是subprocess,这是一个非常重要的函数,相信大多数人已经知道啦,这个函数最主要的就是调用一个外部程序或者shell里的命令,可以用阻塞的方式调用(subprocess.call()),也可以用非阻塞的方式(subprocess.Popen())&lt;/p&gt;

&lt;p&gt;程序中遇到的问题是这样的,cli界面是主程序,用一个while循环去抓取按键,当空格的时候就会播放选中频道的歌曲,然而如果用subprocess调用mplayer播放器,只能播放一首,第二首就会停止,怎么办?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把播放歌曲封装进一个函数,当做一个进程,在进程里无线循环调用歌曲,不停的播放,而界面程序会当做另一个进程监控按键&lt;/li&gt;
&lt;li&gt;创建一个守护进程或者守护线程不停的监听subprocess的状态,如运行完成则立刻进行反应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后我还是选了2,因为2比较简单,1需要的交互太多,比较麻烦&lt;/p&gt;

&lt;p&gt;下面这个程序是个实验小程序,用一个守护进程去监听mplayer,如果播放完毕则重新启用mplayer,无限循环的过程&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------import------------------------------------&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mplayer ~/01\ 21\ Guns\ \(feat.\ The\ Cast\ of\ _Ameri.m4a  &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# time.sleep(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;returncode:&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mplayer ~/01\ 21\ Guns\ \(feat.\ The\ Cast\ of\ _Ameri.m4a  &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;protect&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;############################################################################&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </entry>
    
    <entry>
        <title>Aaron Swartz</title>
        <link href="http://hackerxu.com/2014/09/20/Aaron-Swartz.html"/>
        <updated>2014-09-20T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/09/20/Aaron-Swartz</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/Aaron_Swartz_at_Boston_Wikipedia_Meetup,_2009-08-18.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？如果你没在做那最重要的事，那又是为什么？&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>数据挖掘笔记</title>
        <link href="http://hackerxu.com/2014/09/16/datamining1.html"/>
        <updated>2014-09-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/09/16/datamining1</id>
        <content type="html">&lt;h2&gt;Chanpter 2 Data Preprocessing(数据预处理)&lt;/h2&gt;

&lt;p&gt;定期更新中~October 11 2014 10:36 AM&lt;/p&gt;

&lt;h3&gt;1 Why preprocess the data?(数据预处理的必要性）&lt;/h3&gt;

&lt;p&gt;要进行数据挖掘需要把数据进行预处理,最简单的原因就是如果提供了完整干净的数据集,那么在数据挖掘的过程中就不用考虑这些东西了,所以很有必要.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不完整(缺少属性值)&lt;/li&gt;
&lt;li&gt;含噪音(错误的值或者偏离太大的值)&lt;/li&gt;
&lt;li&gt;不一致(比如字符串和整数相混)&lt;/li&gt;
&lt;li&gt;重复的(一个人对应几个名字)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;把大象装冰箱总共分四部:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据清理(Data cleaning): 可以去掉数据中的噪声，纠正不一致&lt;/li&gt;
&lt;li&gt;数据集成(Data integration): 将多个数据源合并成一致的数据存储，构成一个完整的数据集，如数据仓库或数据立方体&lt;/li&gt;
&lt;li&gt;数据变换(Data transformation): 将一种格式的数据转换为另一格式的数据(如规范化)&lt;/li&gt;
&lt;li&gt;数据归约(Data reduction): 可以通过聚集、删除冗余特性或聚类等方法来压缩数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-09-17%2016:52:40%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;2 Descriptive Date Summarization(描述性数据汇总)&lt;/h3&gt;

&lt;p&gt;这些东西可以更加直观的观测数据,更好的理解数据&lt;/p&gt;

&lt;h4&gt;Measuring the Central Tendency（度量数据的中心趋势）&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;mean(几何平均数)&lt;/li&gt;
&lt;li&gt;median(中值)&lt;/li&gt;
&lt;li&gt;mode(众数): 出现最多的一个数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里有一个经验公式:&lt;/p&gt;

&lt;p&gt;$$ mean - mode = 3 * (mean - median) $$&lt;/p&gt;

&lt;p&gt;条件是单峰的情况下,并且是asymmetrical类型(倾斜的数据)&lt;/p&gt;

&lt;h4&gt;Measuring the Dispersion of Data(度量数据的离散程度)&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Quartiles, outliers and boxplots（四分位数、离散点和盒图）

&lt;ul&gt;
&lt;li&gt;Inter-quartile range: IQR = Q3 – Q1;(Q1(25%),Q3(75%))&lt;/li&gt;
&lt;li&gt;Five number summary: min, Q1, M, Q3, max&lt;/li&gt;
&lt;li&gt;Boxplot(盒图):招不开了,见下&lt;/li&gt;
&lt;li&gt;Outlier: usually, a value higher/lower than 1.5 x IQR&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Variance and standard deviation (sample: s, population: σ)（方差和标准差）&lt;/li&gt;
&lt;li&gt;Properties of Normal Distribution Curve(正态分布特性)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Graphic Displays of Basic Statistical Descriptions(描述数据的基本图形)&lt;/h4&gt;

&lt;p&gt;Boxplot(盒图)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data is represented with a box(一个盒子来表示)&lt;/li&gt;
&lt;li&gt;The ends of the box are at the first and third quartiles, i.e., the height of the box is IRQ(上下边界分别是四分位点,即Q1和Q3,高度就是IRQ的高度了)&lt;/li&gt;
&lt;li&gt;The median is marked by a line within the box(中值在盒子里用一个线表示)&lt;/li&gt;
&lt;li&gt;Whiskers: two lines outside the box extend to Minimum and Maximum(盒子外两条线延伸到最大最小值)&lt;/li&gt;
&lt;li&gt;whiskers(上面两条线)长度不会大于1.5 * IRQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;来感受下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/Cpb7Fx.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Histogram Analysis(直方图)&lt;/p&gt;

&lt;p&gt;Quantile Plot(分位数图)&lt;/p&gt;

&lt;p&gt;Quantile-Quantile (Q-Q) Plot()(Q-Q图,横纵坐标都为分位数)&lt;/p&gt;

&lt;p&gt;Scatter plot（散点图）&lt;/p&gt;

&lt;p&gt;Loess (local regression) curve(回归曲线?): add a smooth curve to a scatter plot to provide better perception of the pattern of dependence&lt;/p&gt;

&lt;h3&gt;3 Data Cleaning&lt;/h3&gt;

&lt;p&gt;数据清理分以下几步:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;填充空缺的值&lt;/li&gt;
&lt;li&gt;识别孤立点&lt;/li&gt;
&lt;li&gt;消除噪声&lt;/li&gt;
&lt;li&gt;纠正数据中的不一致&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Missing Values(空缺数据)&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;忽略该元组(最常用的)&lt;/li&gt;
&lt;li&gt;人工填写空缺值: 量太大!&lt;/li&gt;
&lt;li&gt;使用一个全局常量填充空缺值: 将空缺的属性值用同一个常数(如“Unknown”或)替换。如果空缺值都用“Unknown”替换，当空缺值较多时。挖掘程序可能误以为它们形成了一个有趣的概念，因为它们都具有相同的值——“Unknown”。因此，尽管该方法简单，我们并不推荐它。&lt;/li&gt;
&lt;li&gt;使用属性的平均值填充空缺值&lt;/li&gt;
&lt;li&gt;利用同类别均值填补遗漏数据: 例如，如果将顾客按credit risk分类， 则用具有相同信用度的顾客的平均收入替换income中的缺值&lt;/li&gt;
&lt;li&gt;使用最可能的值填充空缺值:可以利用回归、贝叶斯计算公式或判定树归纳确定，推断出该条记录特定属性最大可能的取值。例如，利用数据集中其他顾客的属性，可以构造一棵判定树，来预测income的空缺值。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Noisy Data&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;binning(分箱)&lt;/strong&gt;: 分箱方法通过考察“邻居”(即周围的值)来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法参考相邻的值，因此它进行局部平滑。这里平滑方法又分了3种

&lt;ul&gt;
&lt;li&gt;按箱平均值平滑&lt;/li&gt;
&lt;li&gt;按箱中值平滑&lt;/li&gt;
&lt;li&gt;按箱边界平滑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clustering(聚类)&lt;/strong&gt;: 通过聚类分析可以检测孤立点，聚类将类似的值组织成群或“聚类”。直观地看，落在聚类集合之外的值被视为孤立点,这个方法在机器学习里有过了解.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;regression(回归)&lt;/strong&gt;: 以利用拟合函数(如回归函数)来平滑数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;4 Data Integration(数据集成)&lt;/h3&gt;

&lt;p&gt;它需要统一原始数据中的所有矛盾之处，如字段的:同名异义、异名同义、单位不统一,字长不一致，从而把原始数据在最低层上加以转换，提炼和集成。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;模式集成&lt;/strong&gt;: 通常，数据库和数据仓库有元数据——关于数据的数据。这种元数据可以帮助避免模式集成中的错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冗余问题&lt;/strong&gt;: 可以用概率的方法算出两个数据是相关还是独立,这种分析可以度量一个属性能在多大程度上蕴含另一个.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据值冲突的检测与处理&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;表示不同导致数据冲突&lt;/li&gt;
&lt;li&gt;语义不同导致数据冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于现实世界的同一实体，来自不同数据源的属性值可能不同。这可能是因为表示、比例或编码不同。例如，重量属性可能在一个系统中以公制单位存放，而在另一个系统中以英制单位存放。不同旅馆的价格不仅可能涉及不同的货币，而且可能涉及不同的服务(如免费早餐)和税。数据这种语义上的异种性，是数据集成的巨大挑战。&lt;/p&gt;

&lt;p&gt;将多个数据源中的数据集成起来，能够减少或避免结果数据集中数据的冗余和不一致性。这有助于提高其后挖掘的精度和速度。另外，在数据集成中还应考虑数据类型的选择问题，如在值域范围内应尽量用tinyint代替int, 可大大减少字节数，对于大规模数据集来说将会大大减少系统开销。&lt;/p&gt;

&lt;h3&gt;5 Data Transformation(数据变换)&lt;/h3&gt;

&lt;p&gt;数据变换将数据转换成适合于挖掘的形式。主要是找到数据的特征表示，对数据进行规格化处理。用维变换或转换方式减少有效变量的数目或找到数据的不变式.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;smoothing(平滑)&lt;/strong&gt;: 去掉数据中的噪声。这种技术包括分箱（Bin)、聚类和回归。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aggregation(聚集)&lt;/strong&gt;:对数据进行汇总和聚集例如，可以聚集日销售数据，计算月和年销售额。这一步用来为多粒度数据分析构造数据立方体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generalization(概化)&lt;/strong&gt;:使用概念分层，用高层次概念替换低层次“原始”数据。例如，分类的属性，如street，可以概化为较高层的概念，如city或country.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Normalization(规范化)&lt;/strong&gt;: 将属性数据按比例缩放，使之落入一个小的特定区间，如-1．0到1．0或0.0到1.0。规格化的目的是将一个属性取值范围影射到一个特定范围之内，以消除数值性属性因大小不一而造成挖掘结果的偏差.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attribute construction属性构造或特征构造&lt;/strong&gt;: 可以利用已知的属性构造新的属性并添加到属性集中，以帮助挖掘过程。(由长，宽求面积)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;7 Data Reduction(数据归约)&lt;/h3&gt;

&lt;p&gt;主要以下方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Data cube aggregation(数据方聚集):聚集操作用于数据方中的数据。主要用来构建数据立方.
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-10-11%2010:28:48%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;Atrribute subset selection(维归约):可以检测并删除不相关、弱相关或冗余的属性或维。(去除多余的属性值)&lt;/li&gt;
&lt;li&gt;Dimensionality reduction(数据压缩):使用编码机制压缩数据集。

&lt;ul&gt;
&lt;li&gt;discrete wavelet transform小波变换DWT&lt;/li&gt;
&lt;li&gt;principal components analysis 主要成分分析&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Numerosity reduction(数值压缩):用替代的、较小的数据表示替换或估计数据,如参数模型(只需要存放模型参数,而不是实际数据)或非参数方法,如&lt;strong&gt;聚类&lt;/strong&gt;、&lt;strong&gt;选样&lt;/strong&gt;和使用&lt;strong&gt;直方图&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Discretization and concept hierarchy generation(离散化和概念分层产生):属性的原始值用区间值或较高层的概念替换。概念分层允许挖掘多个抽象层上的数据,是数据挖掘的一种强有力的工具。
五种数值概念分层产生方法:

&lt;ul&gt;
&lt;li&gt;分箱&lt;/li&gt;
&lt;li&gt;直方图分析&lt;/li&gt;
&lt;li&gt;聚类分析&lt;/li&gt;
&lt;li&gt;基于熵的离散化&lt;/li&gt;
&lt;li&gt;通过“自然划分”的数据分段 :  &lt;strong&gt;3-4-5 规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Chapter 3 Data warehouse and OLAP technology:an overview(数据仓库和数据挖掘的 OLAP 技术)&lt;/h2&gt;
</content>
    </entry>
    
    <entry>
        <title>Atom编辑器</title>
        <link href="http://hackerxu.com/2014/09/16/atom-setting.html"/>
        <updated>2014-09-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/09/16/atom-setting</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-09-17%2019:21:54%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最近在用atom编辑器,github出的东西想想怎么都不该差的,不过atom可能正处于一个刚开始起步的阶段,许多功能还没有被完善,发现了许多欠缺和不妥的地方&lt;/p&gt;

&lt;p&gt;缺点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行相比sublime慢.sublime是用c++写的,而atom运行在庞大冗余的V8内核之上&lt;/li&gt;
&lt;li&gt;没有上一次文件夹保存功能.每次我打开atom都得重新寻找项目路径,不知道是不是我打开的方式不对.&lt;/li&gt;
&lt;li&gt;插件不全.刚起步atom的插件数量明显比不过sublime之类啊&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作为一个github强推的核心编辑器,必然与github有深度的整合,这方面无人能比,修改,增添文件都在侧边栏可以高亮显示(这个再sublime上没有找到),文件中边框也显示哪行修改,删除或者新加(虽然sublime和vim都有这个功能),这也是我喜欢atom的主要原因之一&lt;/li&gt;
&lt;li&gt;插件一键安装.的确atom提供的不是一个编辑器,而是一个线上的服务,更新插件so easy&lt;/li&gt;
&lt;li&gt;因为atom是基于chrome的V8的,所以全平台支持,而且插件都是用coffeescript编写,方便开发者&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作为一个非前端coder,感觉还是够用了,自己虽然是一个vimer,但是涉及到前端的东西感觉还得是atom,sublime之类的编辑器更方便点(代码看得更舒服).&lt;/p&gt;

&lt;p&gt;试用的几个插件:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/atom-beautify&quot;&gt;atom-beautify&lt;/a&gt;:美化丑陋的代码~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/git-plus&quot;&gt;git-plus&lt;/a&gt;:git操作&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/color-picker&quot;&gt;color-picker&lt;/a&gt;:获取颜色的插件,右键直接打开一个颜色值进行调整&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/markdown-preview&quot;&gt;Markdown Preview package&lt;/a&gt;:预览markdown插件&lt;code&gt;ctrl + shift +m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/sort-lines&quot;&gt;sort-lines&lt;/a&gt;:一个给文本单词排序的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/bracket-matcher&quot;&gt;Bracket Matcher package &lt;/a&gt;:括号匹配插件,&lt;code&gt;ctrl + m&lt;/code&gt;跳转匹配括号,好像linux不太好使~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Tree View package&lt;/a&gt;:自带插件,&lt;code&gt;ctrl + \&lt;/code&gt; 打开 , &lt;code&gt;ctrl + 0&lt;/code&gt; 选中树形图, &lt;code&gt;a,m,delete&lt;/code&gt; 分别为增加,移动和删除&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/fuzzy-finder&quot;&gt;fuzzy-finder&lt;/a&gt;: &lt;code&gt;ctrl+t&lt;/code&gt; 打开快速查找项目中的文件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://atom.io/packages/git-log&quot;&gt;gitlog&lt;/a&gt;:查看git日志&lt;/p&gt;
</content>
    </entry>
    

</feed>
