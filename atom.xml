<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>Hackerxu's Blog</title>
    <subtitle>Python,HTML,CSS,Machine Leaning</subtitle>
    <link href="http://hackerxu.com/atom.xml" rel="self"/>
    <link href="http://hackerxu.com"/>
    <updated>2014-11-16T11:59:13+08:00</updated>
    <id>http://hackerxu.com</id>
    <author>
        <name>xuxiao</name>
    </author>
    
    <entry>
        <title>TCP三次握手</title>
        <link href="http://hackerxu.com/2014/11/16/TCP.html"/>
        <updated>2014-11-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/16/TCP</id>
        <content type="html">&lt;p&gt;上周终于面了知乎,结果跪了~一是基础还不怎么扎实,二是没有准备,原以为能在12月分面试呢,结果发完题过两天就发了面试通知,不过知乎的态度真的不错,面了一个半点,虽然大多数问的问题都能知道,但是平时都没深入了解,所以今天总结一下TCP协议.&lt;/p&gt;

&lt;h2&gt;TCP图示&lt;/h2&gt;

&lt;p&gt;TCP(Transmission Control Protocol)传输控制协议.&lt;/p&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/ae52f886642e0019fa0973268eeb08b4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;TCP状态&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/375102e721925d18e6ac4e994a5ace8f.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面图中白色部分是TCP协议的字段,可以看到TCP的flag有6个,着重介绍下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;URG:紧急URG,当URG置为1时,发送应用进程就告诉发送方的TCO有紧急数据发送,于是发送方TCP就把紧急数据插入到&lt;strong&gt;本报文段数据的最前面&lt;/strong&gt;.*(例如用户从键盘发出中断命令,如果不使用紧急数据那么这个命令就会放在TCO的缓存末尾,这样浪费很多时间)&lt;/li&gt;
&lt;li&gt;ACK:当ACK=1时&lt;code&gt;Acknowledgment Number&lt;/code&gt;才有效.(仅在三次握手第一次握手时ACK=0,其他时刻ACK都为1)&lt;/li&gt;
&lt;li&gt;PSH:操作很少用到,当接受方TCP接受到PSH=1的报文段,就尽快的PUSH给接收应用进程,而不再等待整个缓存都填满后再向上交付.&lt;/li&gt;
&lt;li&gt;RST:当RST=1时说明发生了严重错误,必须释放连接,然后重新建立运输连接.&lt;/li&gt;
&lt;li&gt;SYN:连接建立时的同步信号,后面会说.&lt;/li&gt;
&lt;li&gt;FIN:释放连接,后面会说.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;三次握手&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次握手:
客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327002911.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次握手:
服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003054.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次握手.
客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003214.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在wireshark上看一下包的传递,下面以解析百度首页为例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2010:38:22%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以清楚的看到前三个包就是三次握手的TCP包,所有包中有用信息都在info里,再来解释下其他字段含义:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Win:窗口字段明确指出&lt;strong&gt;现在&lt;/strong&gt;允许&lt;strong&gt;对方&lt;/strong&gt;发送的数据量(经常变化)&lt;/li&gt;
&lt;li&gt;Len:暂时未知,TCP字段未有这个关键字?&lt;/li&gt;
&lt;li&gt;MSS(Maximum Segment Size):最大报文段长度,即每个TCP报文段中的数据字段的最大长度.这里需要在握手的时候进行协商,双方都给出MSS,最后以最小MSS确定为最终的MSS.IP数据报最大传输单位为MTU(Maximum Transmission Unit，Effect of short board),对于大多数使用以太网的局域网来说，MTU=1500。MSS往往基于MTU计算出来，通常MSS=MTU-sizeof(IP Header)-sizeof(TCP Header)=1500-20-20=1460,这里我们看到服务器MSS=1460,而客户端的MSS=1440,所以最终为1440.&lt;/li&gt;
&lt;li&gt;SACK_PERM:选择确认字段,如果中间缺少包而其他包都已经接收,那么直接传送缺少包.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三次握手和其他数据传输包没有区别,原因是这个包是为了改变服务器状态,使服务器从半连接状态转换为全连接状态.&lt;/p&gt;

&lt;h2&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/u=220219588,1869709485&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。&lt;/li&gt;
&lt;li&gt;服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。&lt;/li&gt;
&lt;li&gt;服务器B关闭与客户端A的连接，发送一个FIN给客户端A。&lt;/li&gt;
&lt;li&gt;客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在来看看百度的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2011:54:51%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;其实第2,4部和普通的数据传输包没有区别,关键是第1,3个FIN包,它们告诉对方自己将不传送信息,只接受信息.所以TCP的四次挥手可以看成是&lt;strong&gt;两个二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;为什么采用3次握手而不是2次握手?&lt;/h4&gt;

&lt;p&gt;如果两次握手的话,客户端有可能因为网络阻塞等原因会发送多个请求报文,这时服务器就会建立连接,浪费掉许多服务器的资源.&lt;/p&gt;

&lt;h4&gt;为什么建立连接是三次握手，而关闭连接却是四次挥手呢？&lt;/h4&gt;

&lt;p&gt;这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>粒子群算法(转)</title>
        <link href="http://hackerxu.com/2014/11/14/PSO.html"/>
        <updated>2014-11-14T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/14/PSO</id>
        <content type="html">&lt;p&gt;本文整理自: &lt;a href=&quot;http://blog.csdn.net/niuyongjie/article/details/1569671&quot;&gt;http://blog.csdn.net/niuyongjie/article/details/1569671&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;粒子群算法简介&lt;/h1&gt;

&lt;h2&gt;1 粒子群算法的历史&lt;/h2&gt;

&lt;p&gt;粒子群算法源于复杂适应系统（Complex Adaptive System,CAS）。CAS理论于1994年正式提出，CAS中的成员称为主体。比如研究鸟群系统，每个鸟在这个系统中就称为主体。主体有适应性，它能够与环境及其他的主体进行交流，并且根据交流的过程“学习”或“积累经验”改变自身结构与行为。整个系统的演变或进化包括：新层次的产生（小鸟的出生）；分化和多样性的出现（鸟群中的鸟分成许多小的群）；新的主题的出现（鸟寻找食物过程中，不断发现新的食物）。&lt;/p&gt;

&lt;p&gt;所以CAS系统中的主体具有4个基本特点（这些特点是粒子群算法发展变化的依据）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，主体是主动的、活动的。&lt;/li&gt;
&lt;li&gt;主体与环境及其他主体是相互影响、相互作用的，这种影响是系统发展变化的主要动力。&lt;/li&gt;
&lt;li&gt;环境的影响是宏观的，主体之间的影响是微观的，宏观与微观要有机结合。&lt;/li&gt;
&lt;li&gt;最后，整个系统可能还要受一些随机因素的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粒子群算法就是对一个CAS系统－－－鸟群社会系统的研究得出的。&lt;/p&gt;

&lt;p&gt;粒子群算法（ Particle Swarm Optimization, PSO）最早是由Eberhart和Kennedy于1995年提出，它的基本概念源于对鸟群觅食行为的研究。设想这样一个场景:一群鸟在随机搜寻食物，在这个区域里只有一块食物，所有的鸟都不知道食物在哪里，但是它们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢?最简单有效的就是搜寻目前离食物最近的鸟的周围区域。&lt;/p&gt;

&lt;p&gt;PSO算法就从这种生物种群行为特性中得到启发并用于求解优化问题。在PSO中，每个优化问题的潜在解都可以想象成d维搜索空间上的一个点，我们称之为“粒子”（Particle），所有的粒子都有一个被目标函数决定的适应值(Fitness Value )，每个粒子还有一个速度决定他们飞翔的方向和距离，然后粒子们就追随当前的最优粒子在解空间中搜索。Reynolds对鸟群飞行的研究发现。鸟仅仅是追踪它有限数量的邻居但最终的整体结果是整个鸟群好像在一个中心的控制之下.即复杂的全局行为是由简单规则的相互作用引起的。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的具体表述&lt;/h2&gt;

&lt;p&gt;上面罗嗦了半天，那些都是科研工作者写论文的语气，不过，PSO的历史就像上面说的那样。下面通俗的解释PSO算法。&lt;/p&gt;

&lt;p&gt;PSO算法就是模拟一群鸟寻找食物的过程，每个鸟就是PSO中的粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，不停改变自己在空中飞行的位置与速度。大家也可以观察一下，鸟群在寻找食物的过程中，开始鸟群比较分散，逐渐这些鸟就会聚成一群，这个群忽高忽低、忽左忽右，直到最后找到食物。这个过程我们转化为一个数学问题。寻找函数&lt;code&gt;y=1-cos(3*x)*exp(-x)&lt;/code&gt;的在[0,4]最大值。该函数的图形如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_hanshutuxing.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;当x=0.9350-0.9450，达到最大值y=1.3706。为了得到该函数的最大值，我们在[0，4]之间随机的洒一些点，为了演示，我们放置两个点，并且计算这两个点的函数值，同时给这两个点设置在[0，4]之间的一个速度。下面这些点就会按照一定的公式更改自己的位置，到达新位置后，再计算这两个点的值，然后再按照一定的公式更新自己的位置。直到最后在y=1.3706这个点停止自己的更新。这个过程与粒子群算法作为对照如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这两个点就是粒子群算法中的粒子。&lt;/li&gt;
&lt;li&gt;该函数的最大值就是鸟群中的食物 &lt;/li&gt;
&lt;li&gt;计算两个点函数值就是粒子群算法中的适应值，计算用的函数就是粒子群算法中的适应度函数。&lt;/li&gt;
&lt;li&gt;更新自己位置的一定公式就是粒子群算法中的位置速度更新公式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面演示一下这个算法运行一次的大概过程：&lt;/p&gt;

&lt;p&gt;第一次初始化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi1.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi2.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi3.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第21次更新:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi4.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后的结果（30次迭代）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi5.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后所有的点都集中在最大值的地方。&lt;/p&gt;

&lt;p&gt;呵呵，现在粒子群算法的大概思想就说到这里。下节介绍标准的粒子群算法.&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法&lt;/h1&gt;

&lt;p&gt;在上一节的叙述中，唯一没有给大家介绍的就是函数的这些随机的点（粒子）是如何运动的，只是说按照一定的公式更新。这个公式就是粒子群算法中的位置速度更新公式。下面就介绍这个公式是什么。在上一节中我们求取函数y=1-cos(3*x)*exp(-x)的在[0,4]最大值。并在[0,4]之间放置了两个随机的点，这些点的坐标假设为$x_1=1.5$；$ x_2=2.5$；这里的点是一个标量，但是我们经常遇到的问题可能是更一般的情况－－x为一个矢量的情况，比如二维的情$况 z=2*x_1+3*x_2$的情况。这个时候我们的每个粒子为二维，记粒$子P_1＝(x_{11},x_{12}),P2=(x_{21},x_{22}),P3=(x_{31},x_{32})，......Pn=(x_{n1},x_{n2})$。这里n为粒子群群体的规模，也就是这个群中粒子的个数，每个粒子的维数为2。更一般的是粒子的维数为q，这样在这个种群中有n个粒子，每个粒子为q 维。&lt;/p&gt;

&lt;p&gt;由n个粒子组成的群体对Q维（就是每个粒子的维数）空间进行搜索。每个粒子表示为：$xi＝（x_{i1},x_{i2},x_{i3},...,x_{iQ}）$，每个粒子对应的速度可以表示为$vi=(v_{i1},v_{i2},v_{i3},....,v_{iQ})$，每个粒子在搜索时要考虑两个因素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自己搜索到的历史最优值 $p_i ，p_i=(p_{i1},p_{i2},....,p_{iQ})$，i=1,2,3,....,n。&lt;/li&gt;
&lt;li&gt;全部粒子搜索到的最优值$p_g，p_g=(p_{g1},p_{g2},....,p_{gQ})$，注意这里的$p_g$只有一个。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面给出粒子群算法的位置速度更新公式：&lt;/p&gt;

&lt;p&gt;$$v_{id}^{k+1} = wv_{id}^{k} + c_1\xi(p_{id}^k - x_{id}^k) + c_2\eta(p_{gd}^{k} - x_{id}^k)$$&lt;/p&gt;

&lt;p&gt;$$x_{id}^{k+1} = x_{id}^{k} + rv_{id}^{k+1}$$&lt;/p&gt;

&lt;p&gt;这里有几个重要的参数需要大家记忆，因为在以后的讲解中将会经常用到,它们是：&lt;/p&gt;

&lt;p&gt;$w$是保持原来速度的系数，所以叫做&lt;strong&gt;惯性权重&lt;/strong&gt;。
$c_1$是粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，所以叫“&lt;strong&gt;认知&lt;/strong&gt;”。通常设置为2。
$\xi$  $\eta$是[0,1]区间内均匀分布的随机数。
$r$是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做&lt;strong&gt;约束因子&lt;/strong&gt;。通常设置为1。&lt;/p&gt;

&lt;p&gt;这样一个标准的粒子群算法就结束了。&lt;/p&gt;

&lt;p&gt;下面对整个基本的粒子群的过程给一个简单的图形表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_liucheng.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;判断终止条件可是设置适应值到达一定的数值或者循环一定的次数。&lt;/p&gt;

&lt;p&gt;注意：这里的粒子是同时跟踪自己的历史最优值与全局（群体）最优值来改变自己的位置预速度的，所以又叫做&lt;strong&gt;全局版本的标准粒子群优化算法&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法(局部版本)&lt;/h1&gt;

&lt;p&gt;在全局版的标准粒子群算法中，每个粒子的速度的更新是根据两个因素来变化的，这两个因素是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子群体的全局最优值$p_g$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果改变粒子速度更新公式，让每个粒子的速度的更新根据以下两个因素更新，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子&lt;strong&gt;邻域内&lt;/strong&gt;粒子的最优值$pn_k$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其余保持跟全局版的标准粒子群算法一样，这个算法就变为局部版的粒子群算法。&lt;/p&gt;

&lt;p&gt;一般一个粒子i 的邻域随着迭代次数的增加而逐渐增加，开始第一次迭代，它的邻域为0，随着迭代次数邻域线性变大，最后邻域扩展到整个粒子群，这时就变成全局版本的粒子群算法了。经过实践证明：全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在&lt;strong&gt;收敛速度与摆脱局部最优&lt;/strong&gt;这两个方面下功夫。其实这两个方面是矛盾的。看如何更好的折中了。&lt;/p&gt;

&lt;p&gt;根据取邻域的方式的不同，局部版本的粒子群算法有很多不同的实现方法.&lt;/p&gt;

&lt;p&gt;第一种方法：按照粒子的编号取粒子的邻域，取法有四种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;环形取法 &lt;/li&gt;
&lt;li&gt;随机环形取法 &lt;/li&gt;
&lt;li&gt;轮形取法 &lt;/li&gt;
&lt;li&gt;随机轮形取法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_huan.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;因为后面有以环形取法实现的算法，对环形取法在这里做一点点说明：以粒子1为例，当邻域是0的时候，邻域是它本身，当邻域是1时，邻域为2，8；当邻域是2时，邻域是2，3，7，8；......，以此类推，一直到邻域为4，这个时候，邻域扩展到整个例子群体。据文献介绍（&lt;strong&gt;国外的文献&lt;/strong&gt;），采用轮形拓扑结构，PSO的效果很好。&lt;/p&gt;

&lt;p&gt;第二种方法：按照粒子的欧式距离取粒子的邻域&lt;/p&gt;

&lt;p&gt;在第一种方法中，按照粒子的编号来得到粒子的邻域，但是这些粒子其实可能在实际位置上并不相邻，于是Suganthan提出基于空间距离的划分方案，在迭代中计算每一个粒子与群中其他粒子的距离。记录任何2个粒子间的的最大距离为dm。对每一粒子按照$||x_a-x_b||/dm$计算一个比值。其中||xa-xb||是当前粒子a到b的距离。而选择阈值frac根据迭代次数而变化。当另一粒子b满足$||x_a-x_b||/dm &amp;lt; frac$时，认为b成为当前粒子的邻域。&lt;/p&gt;

&lt;p&gt;这种办法经过实验，取得较好的应用效果，但是由于要计算所有粒子之间的距离，计算量大，且需要很大的存储空间，所以，&lt;strong&gt;该方法一般不经常使用&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;粒子群算法分类&lt;/h1&gt;

&lt;p&gt;粒子群算法主要分为4个大的分支：&lt;/p&gt;

&lt;h2&gt;1 标准粒子群算法的变形&lt;/h2&gt;

&lt;p&gt;在这个分支中，主要是对标准粒子群算法的惯性因子、收敛因子（约束因子）、“认知”部分的$c_1$，“社会”部分的$c_2$进行变化与调节，希望获得好的效果。&lt;/p&gt;

&lt;p&gt;惯性因子的原始版本是保持不变的，后来有人提出随着算法迭代的进行，惯性因子需要逐渐减小的思想。算法开始阶段，大的惯性因子可以使算法不容易陷入局部最优，到算法的后期，小的惯性因子可以使收敛速度加快，使收敛更加平稳，不至于出现振荡现象。&lt;strong&gt;经过本人测试&lt;/strong&gt;，动态的减小惯性因子w，的确可以使算法更加稳定，效果比较好。但是递减惯性因子采用什么样的方法呢？人们首先想到的是线型递减，这种策略的确很好，但是是不是最优的呢？于是有人对递减的策略作了研究，研究结果指出：线型函数的递减优于凸函数的递减策略，但是凹函数的递减策略又优于线型的递减，经过本人测试，实验结果基本符合这个结论，但是效果不是很明显。&lt;/p&gt;

&lt;p&gt;对于收敛因子，经过证明如果收敛因子取0.729,可以确保算法的收敛，但是不能保证算法收敛到全局最优，经过本人测试，取收敛因子为0.729效果较好。对于社会与认知的系数$c_1$,$c_2$也有人提出：$c_1$先大后小，而$c_2$先小后大的思想，因为在算法运行初期，每个鸟要有大的自己的认知部分而又比较小的社会部分，这个与我们自己一群人找东西的情形比较接近，因为在我们找东西的初期，我们基本依靠自己的知识取寻找，而后来，我们积累的经验越来越丰富，于是大家开始逐渐达成共识（社会知识），这样我们就开始依靠社会知识来寻找东西了。&lt;/p&gt;

&lt;p&gt;2007年希腊的两位学者提出将收敛速度比较快的全局版本的粒子群算法与不容易陷入局部最优的局部版本的粒子群算法相结合的办法，利用的公式是:&lt;/p&gt;

&lt;p&gt;速度更新公式，v代表速度&lt;/p&gt;

&lt;p&gt;$$ v＝n*v(全局版本)＋（1－n）*v(局部版本) $$&lt;/p&gt;

&lt;p&gt;位置更新公式&lt;/p&gt;

&lt;p&gt;$$w（k＋1）＝w(k)＋v$$&lt;/p&gt;

&lt;p&gt;该算法在文献中讨论了系数n取各种不同情况的情况，并且运行来了20000次来分析各种系数的结果。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的混合&lt;/h2&gt;

&lt;p&gt;这个分支主要是将粒子群算法与各种算法相混合，有人将它与模拟退火算法相混合，有些人将它与单纯形方法相混合。但是最多的是将它与遗传算法的混合。根据遗传算法的三种不同算子可以生成3中不同的混合算法。&lt;/p&gt;

&lt;h3&gt;粒子群算法与选择算子的结合&lt;/h3&gt;

&lt;p&gt;这里相混合的思想是：在原来的粒子群算法中，我们选择粒子群群体的最优值作为$p_g$，但是相结合的版本是根据所有粒子的适应度的大小给每个粒子赋予一个被选中的概率，然后依据概率对这些粒子进行选择，被选中的粒子作为$p_g$，其它的情况都不变。这样的算法可以在算法运行过程中保持粒子群的多样性，但是致命的缺点是收敛速度缓慢。&lt;/p&gt;

&lt;h3&gt;粒子群算法与杂交算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想与遗传算法的基本一样，在算法运行过程中根据适应度的大小，粒子之间可以两两杂交，比如用一个很简单的公式:&lt;/p&gt;

&lt;p&gt;$$w（新）＝n×w_1＋（1－n）×w_2$$&lt;/p&gt;

&lt;p&gt;w1与w2就是这个新粒子的父辈粒子。&lt;/p&gt;

&lt;p&gt;这种算法可以在算法的运行过程中引入新的粒子，但是算法一旦陷入局部最优，那么粒子群算法将很难摆脱局部最优。&lt;/p&gt;

&lt;h3&gt;粒子群算法与变异算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想：测试所有粒子与当前最优的距离，当距离小于一定的数值的时候，可以拿出所有粒子的一个百分比（如10％）的粒子进行随机初始化，让这些粒子重新寻找最优值。&lt;/p&gt;

&lt;h2&gt;3 二进制粒子群算法&lt;/h2&gt;

&lt;p&gt;最初的PSO是从解决连续优化问题发展起来的.Eberhart等又提出了PSO的离散二进制版.用来解决工程实际中的组合优化问题。他们在提出的模型中将粒子的每一维及粒子本身的历史最优、全局最优限制为1或0，而速度不作这种限制。用速度更新位置时，设定一个阈值，当速度高于该阈值时，粒子的位置取1，否则取0。二进制PSO与遗传算法在形式上很相似，但实验结果显示，在大多数测试函数中，二进制PSO比遗传算法速度快，尤其在问题的维数增加时.&lt;/p&gt;

&lt;h2&gt;4 协同粒子群算法&lt;/h2&gt;

&lt;p&gt;协同PSO，该方法将粒子的D维分到D个粒子群中，每个粒子群优化一维向量，评价适应度时将这些分量合并为一个完整的向量。例如第i个粒子群，除第i个分量外，其他D-1个分量都设为最优值，不断用第i个粒子群中的粒子替换第i个分量，直到得到第i维的最优值，其他维相同。为将有联系的分量划分在一个群，可将D维向量分配到m个粒子群优化，则前D mod m个粒子群的维数是D/m的向上取整。后m－(D mod m)个粒子群的维数是D/m的向下取整。协同PSO在某些问题上有更快的收敛速度，但该算法容易被欺骗。&lt;/p&gt;

&lt;p&gt;基本的粒子群算法的分支就着4个，大部分的粒子群算法都围绕着这4个分支在变化，其中粒子群算法的变形居多，从根本上来说，几乎没有什么新的思想的提出。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>草帽星系</title>
        <link href="http://hackerxu.com/2014/10/26/habo.html"/>
        <updated>2014-10-26T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/26/habo</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/900x600_A9FVD2A84T8F0001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;渺小的人类&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>数据挖掘之Apriori算法</title>
        <link href="http://hackerxu.com/2014/10/18/apriori.html"/>
        <updated>2014-10-18T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/18/apriori</id>
        <content type="html">&lt;p&gt;关联规则挖掘（Association rule mining）是数据挖掘中最活跃的研究方法之一，可以用来发现事情之间的联系，最早是为了发现超市交易数据库中不同的商品之间的关系。(啤酒与尿布)&lt;/p&gt;

&lt;h4&gt;基本概念&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;支持度的定义：support(X--&amp;gt;Y) = |X交Y|/N=集合X与集合Y中的项在一条记录中同时出现的次数/数据记录的个数。例如：support({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/数据记录数 = 3/5=60%。&lt;/li&gt;
&lt;li&gt;自信度的定义：confidence(X--&amp;gt;Y) = |X交Y|/|X| = 集合X与集合Y中的项在一条记录中同时出现的次数/集合X出现的个数 。例如：confidence({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/啤酒出现的次数=3/3=100%;confidence({尿布}--&amp;gt;{啤酒}) = 啤酒和尿布同时出现的次数/尿布出现的次数 = 3/4 = 75%&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作&lt;strong&gt;强规则&lt;/strong&gt; ,如果项集满足最小支持度,则称它为&lt;strong&gt;频繁项集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“如何由大型数据库挖掘关联规则?”关联规则的挖掘是一个两步的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找出所有频繁项集:根据定义,这些项集出现的频繁性至少和预定义的最小支持计数一样。&lt;/li&gt;
&lt;li&gt;由频繁项集产生强关联规则:根据定义,这些规则必须满足最小支持度和最小置信度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apriori定律&lt;/p&gt;

&lt;p&gt;为了减少频繁项集的生成时间，我们应该尽早的消除一些完全不可能是频繁项集的集合，Apriori的两条定律就是干这事的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律1&lt;/strong&gt;：如果一个集合是频繁项集，则它的所有子集都是频繁项集。举例：假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律2&lt;/strong&gt;：如果一个集合不是频繁项集，则它的所有超集都不是频繁项集。举例：假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/31160727-a7d9a4d0a64a4f4b83a831980273450d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面的图演示了Apriori算法的过程，注意看由二级频繁项集生成三级候选项集时，没有{牛奶,面包,啤酒}，那是因为{面包,啤酒}不是二级频繁项集，这里利用了Apriori定理。最后生成三级频繁项集后，没有更高一级的候选项集，因此整个算法结束，{牛奶,面包,尿布}是最大频繁子集。&lt;/p&gt;

&lt;p&gt;Python实现算法地址&lt;a href=&quot;https://github.com/taizilongxu/datamining&quot;&gt;https://github.com/taizilongxu/datamining&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&quot;&gt;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lizhengnanhua/article/details/9061887&quot;&gt;http://blog.csdn.net/lizhengnanhua/article/details/9061887&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>Python subprocess模块总结</title>
        <link href="http://hackerxu.com/2014/10/09/subprocess.html"/>
        <updated>2014-10-09T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/09/subprocess</id>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;subprocess意在替代其他几个老的模块或者函数，比如：os.system os.spawn* os.popen* popen2.* commands.*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;subprocess最简单的用法就是调用shell命令了,另外也可以调用程序,并且可以通过stdout,stdin和stderr进行交互&lt;/p&gt;

&lt;h4&gt;subprocess的主类&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;bufsize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;executable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;close_fds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;universal_newlines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;startupinfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;creationflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;args可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。&lt;/li&gt;
&lt;li&gt;bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲)&lt;/li&gt;
&lt;li&gt;stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。&lt;/li&gt;
&lt;li&gt;preexec_fn只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。&lt;/li&gt;
&lt;li&gt;Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。&lt;/li&gt;
&lt;li&gt;shell设为true，程序将通过shell来执行。&lt;/li&gt;
&lt;li&gt;cwd用于设置子进程的当前目录&lt;/li&gt;
&lt;li&gt;env是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。&lt;/li&gt;
&lt;li&gt;Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用&amp;#39;/r/n&amp;#39;表示换，而Linux下用&amp;#39;/n&amp;#39;。如果将此参数设置为True，Python统一把这些换行符当作&amp;#39;/n&amp;#39;来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;li&gt;startupinfo与createionflags只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Popen方法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Popen.poll()：用于检查子进程是否已经结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.wait()：等待子进程结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.communicate(input=None)：与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。&lt;/li&gt;
&lt;li&gt;Popen.send_signal(signal)：向子进程发送信号。&lt;/li&gt;
&lt;li&gt;Popen.terminate()：停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。&lt;/li&gt;
&lt;li&gt;Popen.kill()：杀死子进程。&lt;/li&gt;
&lt;li&gt;Popen.stdin：如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stdout：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stderr：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.pid：获取子进程的进程ID。&lt;/li&gt;
&lt;li&gt;Popen.returncode：获取进程的返回值。如果进程还没有结束，返回None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;：运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。文章一开始的例子就演示了call函数。如果子进程不需要进行交互,就可以使用该函数来创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.check_call(*popenargs, **kwargs)&lt;/code&gt;：与&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;功能一样，只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常。在异常对象中，包括进程的returncode信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上全是抄的&lt;/p&gt;

&lt;h4&gt;在程序中运行其他程序或shell&lt;/h4&gt;

&lt;p&gt;可以这样写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.call(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者的区别是前者无阻塞,会和主程序并行运行,后者必须等待命令执行完毕,如果想要前者编程阻塞可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;s = subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
s.wait()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;程序返回运行结果&lt;/h4&gt;

&lt;p&gt;有时候我们需要程序的返回结果,可以这样做&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.Popen(&amp;#39;ls -l&amp;#39;, shell=True, stdout=subprocess.PIPE) 
&amp;gt;&amp;gt;&amp;gt; s.communicate() 
(&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;, None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会返回一个元组：(stdoutdata, stderrdata)&lt;/p&gt;

&lt;p&gt;subprocess还有另一种更简单方法,效果一样,它会返回stdout&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.check_output(&amp;#39;ls -l&amp;#39;, shell=True)
&amp;gt;&amp;gt;&amp;gt; s
&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前者可以实现更多的交互,如stderr和stdin,但是在前面调用Popen的时候要实现定义&lt;code&gt;Popen(stdin=subprocess.PIPE, stderr=subprocess)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;给子进程输入&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;vamei&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;()不为空，则写入subprocess.PIPE，为空，则从subprocess.PIPE读取&lt;/p&gt;

&lt;h4&gt;subprocess.PIPE&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ls&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;-l&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wc&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上是这样的过程&lt;/p&gt;

&lt;p&gt;child1.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdin&amp;lt;--subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;subprocess.PIPE实际上为文本流提供一个缓存区。直到communicate()方法从PIPE中读取出PIPE中的文本.要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/jgood/article/details/4498166&quot;&gt;http://blog.csdn.net/jgood/article/details/4498166&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&quot;&gt;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/imzoer/article/details/8678029&quot;&gt;http://blog.csdn.net/imzoer/article/details/8678029&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ipseek.blog.51cto.com/1041109/807513&quot;&gt;http://ipseek.blog.51cto.com/1041109/807513&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jb51.net/article/48086.htm&quot;&gt;http://www.jb51.net/article/48086.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    </entry>
    
    <entry>
        <title>把程序打包上传到PyPi版本库中</title>
        <link href="http://hackerxu.com/2014/10/08/Pypi.html"/>
        <updated>2014-10-08T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/08/Pypi</id>
        <content type="html">&lt;h4&gt;1 首先必须要按照以下文件结构&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban_token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;必须至少一个包,即上面的douban,把模块都放在包下,且包中必须有&lt;code&gt;__init__.py&lt;/code&gt;文件(可以为空)&lt;/li&gt;
&lt;li&gt;必须有一个setup.py文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;2 setup.py文件&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;setuptools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_packages&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;打包的用的setup必须引入&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0.2.0&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;README.md&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 文件名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 版本(每次更新上传Pypi需要修改)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a tiny and smart cli player of douban.fm based on Python&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 放README.md文件,方便在Pypi页展示&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;classifiers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keywords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;python douban douban.fm terminal&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关键字&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;taizilongxu&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 用户名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;468137306@qq.com&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 邮箱&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;https://github.com/taizilongxu/douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# github上的地址,别的地址也可以&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;license&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;MIT&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 遵循的协议&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 发布的包名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;include_package_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;zip_safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;install_requires&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;termcolor&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 满足的依赖&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry_points&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;console_scripts&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm = douban.douban:main&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; entry_points : [可执行程序名]=引入的包名.子包名.模块名:入口函数.这个要注意了,主程序要引入main函数进行执行.好让包找到执行的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3 安装&lt;/h4&gt;

&lt;p&gt;如果不上传文件,只在本机中安装,那么可以运行以下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就在本机安装了程序,在shell中输入douban.fm(刚才在entry_points中输入的可执行程序名),就可以执行了&lt;/p&gt;

&lt;h4&gt;4 上传到Pypi&lt;/h4&gt;

&lt;p&gt;先在 &lt;a href=&quot;https://pypi.python.org/pypi&quot;&gt;https://pypi.python.org/pypi&lt;/a&gt; 注册个Pypi号,认证邮箱.&lt;/p&gt;

&lt;p&gt;然后再在你的用户目录下新建一个&lt;code&gt;.pypirc&lt;/code&gt;文件,输入如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[distutils]
index-servers =
    pypi

[pypi]
username:
password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把username和password填上保存就可以了&lt;/p&gt;

&lt;p&gt;回到你的setup.py目录,输入如下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo python setup.py register sdist bdist_egg upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你的包就可以发到Pypi里了,通过pip或者easy_install就可以下载你的包了&lt;/p&gt;

&lt;h4&gt;5 更新Pypi包&lt;/h4&gt;

&lt;p&gt;当包版本更新后,需要在你的setup.py文件里修改VERSION,然后运行第4部的命令就可以了(如果不更新VERSION包就不能上传成功)&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>douban.fm 终端命令行豆瓣FM</title>
        <link href="http://hackerxu.com/2014/10/07/doubanfm.html"/>
        <updated>2014-10-07T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/07/doubanfm</id>
        <content type="html">&lt;h2&gt;douban.fm &lt;a href=&quot;https://pypi.python.org/pypi/douban.fm&quot;&gt;&lt;img src=&quot;https://pypip.in/version/douban.fm/badge.svg&quot; alt=&quot;version&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://pypi.python.org/pypi/douban.fm&quot;&gt;&lt;img src=&quot;https://pypip.in/download/douban.fm/badge.png&quot; alt=&quot;Downloads&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这个版本的命令行界面是参考了 Node.js版本的&lt;a href=&quot;https://github.com/turingou/douban.fm&quot;&gt;douban.fm&lt;/a&gt;制作的,向原作者致敬.终端界面设计的非常好看.&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://github.com/cloverstd&quot;&gt;Cloverstd&lt;/a&gt;的修改,已经支持Mac OS X(&amp;gt;=V0.2.9)&lt;/p&gt;

&lt;p&gt;PS:如果喜欢请加Star(&lt;em&gt;^__^&lt;/em&gt;)……&lt;/p&gt;

&lt;h3&gt;Screenshots&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/douban.fm/master/img/out.gif&quot; alt=&quot;screenshot&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Support&lt;/h3&gt;

&lt;p&gt;Linux/Mac OS X&lt;/p&gt;

&lt;h3&gt;Do something cool!&lt;/h3&gt;

&lt;p&gt;其实Node.js版本已经很好了,功能齐全,但是我发现在我的zsh + tmux环境下颜色竟然显示不出来,感觉很蛋疼.&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo pip install douban.fm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要mplayer播放器依赖,如未安装:&lt;/p&gt;

&lt;p&gt;Ubuntu:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo apt-get install mplayer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ brew install mplayer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Usage&lt;/h3&gt;

&lt;p&gt;在终端下直接输入&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ douban.fm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Login&lt;/h3&gt;

&lt;p&gt;第一次登陆需要输入账号,密码,程序不会保留密码,而是保存返回的token存储在~/.douban_token.txt,下次登陆无需输入密码.&lt;/p&gt;

&lt;h3&gt;Keys&lt;/h3&gt;

&lt;p&gt;支持vim按键&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;移动
 [j]     --&amp;gt; 下
 [k]     --&amp;gt; 上
 [g]     --&amp;gt; 移到最顶
 [G]     --&amp;gt; 移到最底
音乐
 [space] --&amp;gt; 播放
 [w]     --&amp;gt; 打开歌曲主页
 [n]     --&amp;gt; 下一首
 [r]     --&amp;gt; 喜欢/取消喜欢
 [b]     --&amp;gt; 不再播放
 [q]     --&amp;gt; 退出
 [p]     --&amp;gt; 暂停
 [l]     --&amp;gt; 单曲循环
音量(&amp;gt;=V0.2.9)
 [=]     --&amp;gt; 增
 [-]     --&amp;gt; 减
 [m]     --&amp;gt; 静音
歌词(&amp;gt;=v0.2.9)
 [o]     --&amp;gt; 显示歌词(Bug很多,先别用,没有反应就是没找到歌词)
 [q]     --&amp;gt; 退出歌词
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Configuration(&amp;gt;=v0.2.8)&lt;/h3&gt;

&lt;p&gt;.doubanfm_config保存在了~/.doubanfm_config,根据需要可以修改按键的映射&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[key]
UP = k       # 上
DOWN = j     # 下
TOP = g      # 顶
BOTTOM = G   # 底
OPENURL = w  # 打开歌曲主页
RATE = r     # 标记喜欢/取消喜欢
NEXT = n     # 下一首
BYE = b      # 不再播放
QUIT = q     # 退出
PAUSE = p    # 暂停
LOOP = l     # 单曲循环
MUTE = m     # 静音
LRC = o      # 歌词
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Done&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;登陆token&lt;/li&gt;
&lt;li&gt;显示PRO&lt;/li&gt;
&lt;li&gt;cli设计&lt;/li&gt;
&lt;li&gt;播放,下一首,红心,不再播放&lt;/li&gt;
&lt;li&gt;进度条(时间)&lt;/li&gt;
&lt;li&gt;终端高度的自动调整&lt;/li&gt;
&lt;li&gt;pro用户歌曲kbps的选择(pro用户会自动选择192kbps)&lt;/li&gt;
&lt;li&gt;歌曲结束request(发送歌曲完成)&lt;/li&gt;
&lt;li&gt;config设置&lt;/li&gt;
&lt;li&gt;调节音量(amixer) + 标题中显示音量&lt;/li&gt;
&lt;li&gt;歌词&lt;/li&gt;
&lt;li&gt;歌曲暂停&lt;/li&gt;
&lt;li&gt;单曲播放&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;TODO&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;默认频道&lt;/li&gt;
&lt;li&gt;播放歌曲数 红心数 不再播放数&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;BUG&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;播放歌曲中有时候会暂停&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;退出后终端光标会隐藏&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;.douban_token.txt路径问题&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;登陆异常处理&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;静音后播放下一首会取消静音&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Authors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Fansion&quot;&gt;Fansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cloverstd&quot;&gt;Cloverstd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.js版本的&lt;a href=&quot;https://github.com/turingou/douban.fm&quot;&gt;douban.fm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skyline75489/pyfm&quot;&gt;豆瓣FM命令行播放器(pyfm)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zonyitoo/doubanfm-qt/wiki/%E8%B1%86%E7%93%A3FM-API&quot;&gt;豆瓣电台 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Log&lt;/h3&gt;

&lt;p&gt;V0.2.11 config兼容问题&lt;/p&gt;

&lt;p&gt;V0.2.10 滚动歌词,单曲循环,暂停,静音&lt;/p&gt;

&lt;p&gt;V0.2.9 支持歌词,支持Mac OS X&lt;/p&gt;

&lt;p&gt;V0.2.8 增加config&lt;/p&gt;

&lt;h3&gt;License (MIT)&lt;/h3&gt;

&lt;p&gt;Copyright (c) 2014 hackerxu&lt;/p&gt;

&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &amp;quot;Software&amp;quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt;

&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt;

&lt;p&gt;THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Douban Fm 之多进程,多线程</title>
        <link href="http://hackerxu.com/2014/10/01/DoubanFm-threading.html"/>
        <updated>2014-10-01T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/01/DoubanFm-threading</id>
        <content type="html">&lt;p&gt;最近Python版本的Douban Fm制作接近尾声,不过困扰我的有一个最大的难题,那就是前台界面和后台程序的融合.&lt;/p&gt;

&lt;p&gt;在以前的编程中虽然语言是面向对象的,但程序的设计主旨一般都还是面向过程的,也就是说平常的程序设计中从来没考虑过进程,线程,以及他们之间的通信.虽然操作系统中对线程,进程都有所了解,但是一想到的是系统编程里的就望而却步了.这会终于好好的研究了一下进程编程,稍后会写笔记,先写写Douban Fm碰到的问题.&lt;/p&gt;

&lt;p&gt;没错,就是线程,进程的问题,当你设计一个cli样式的界面,而且还需要有进程在后端运行,那么你一定需要多线程或是多进程的.在Python里最最原始的方法有一个fork()方法,相信这个方法是从linux中继承过来的,不过这种方法既难掌握,又非常的混乱,比如我们有一个while循环的话,那么在其中的fork()就是一个灾难了.&lt;/p&gt;

&lt;p&gt;相对比较高级的一个方法是multiprocessing,这个函数可以创建一个进程,如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 注意函数没有括号&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数允许你创建一个进程,运行在主程序之外,当然可以和主程序进行一些交互.&lt;/p&gt;

&lt;p&gt;另外一个比较高级的方法是subprocess,这是一个非常重要的函数,相信大多数人已经知道啦,这个函数最主要的就是调用一个外部程序或者shell里的命令,可以用阻塞的方式调用(subprocess.call()),也可以用非阻塞的方式(subprocess.Popen())&lt;/p&gt;

&lt;p&gt;程序中遇到的问题是这样的,cli界面是主程序,用一个while循环去抓取按键,当空格的时候就会播放选中频道的歌曲,然而如果用subprocess调用mplayer播放器,只能播放一首,第二首就会停止,怎么办?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把播放歌曲封装进一个函数,当做一个进程,在进程里无线循环调用歌曲,不停的播放,而界面程序会当做另一个进程监控按键&lt;/li&gt;
&lt;li&gt;创建一个守护进程或者守护线程不停的监听subprocess的状态,如运行完成则立刻进行反应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后我还是选了2,因为2比较简单,1需要的交互太多,比较麻烦&lt;/p&gt;

&lt;p&gt;下面这个程序是个实验小程序,用一个守护进程去监听mplayer,如果播放完毕则重新启用mplayer,无限循环的过程&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------import------------------------------------&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mplayer ~/01\ 21\ Guns\ \(feat.\ The\ Cast\ of\ _Ameri.m4a  &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# time.sleep(1)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;returncode:&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returncode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mplayer ~/01\ 21\ Guns\ \(feat.\ The\ Cast\ of\ _Ameri.m4a  &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;protect&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;############################################################################&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </entry>
    
    <entry>
        <title>Aaron Swartz</title>
        <link href="http://hackerxu.com/2014/09/20/Aaron-Swartz.html"/>
        <updated>2014-09-20T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/09/20/Aaron-Swartz</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/Aaron_Swartz_at_Boston_Wikipedia_Meetup,_2009-08-18.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？如果你没在做那最重要的事，那又是为什么？&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>数据挖掘笔记</title>
        <link href="http://hackerxu.com/2014/09/16/datamining1.html"/>
        <updated>2014-09-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/09/16/datamining1</id>
        <content type="html">&lt;h2&gt;Chanpter 2 Data Preprocessing(数据预处理)&lt;/h2&gt;

&lt;p&gt;定期更新中~October 11 2014 10:36 AM&lt;/p&gt;

&lt;h3&gt;1 Why preprocess the data?(数据预处理的必要性）&lt;/h3&gt;

&lt;p&gt;要进行数据挖掘需要把数据进行预处理,最简单的原因就是如果提供了完整干净的数据集,那么在数据挖掘的过程中就不用考虑这些东西了,所以很有必要.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不完整(缺少属性值)&lt;/li&gt;
&lt;li&gt;含噪音(错误的值或者偏离太大的值)&lt;/li&gt;
&lt;li&gt;不一致(比如字符串和整数相混)&lt;/li&gt;
&lt;li&gt;重复的(一个人对应几个名字)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;把大象装冰箱总共分四部:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据清理(Data cleaning): 可以去掉数据中的噪声，纠正不一致&lt;/li&gt;
&lt;li&gt;数据集成(Data integration): 将多个数据源合并成一致的数据存储，构成一个完整的数据集，如数据仓库或数据立方体&lt;/li&gt;
&lt;li&gt;数据变换(Data transformation): 将一种格式的数据转换为另一格式的数据(如规范化)&lt;/li&gt;
&lt;li&gt;数据归约(Data reduction): 可以通过聚集、删除冗余特性或聚类等方法来压缩数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-09-17%2016:52:40%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;2 Descriptive Date Summarization(描述性数据汇总)&lt;/h3&gt;

&lt;p&gt;这些东西可以更加直观的观测数据,更好的理解数据&lt;/p&gt;

&lt;h4&gt;Measuring the Central Tendency（度量数据的中心趋势）&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;mean(几何平均数)&lt;/li&gt;
&lt;li&gt;median(中值)&lt;/li&gt;
&lt;li&gt;mode(众数): 出现最多的一个数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里有一个经验公式:&lt;/p&gt;

&lt;p&gt;$$ mean - mode = 3 * (mean - median) $$&lt;/p&gt;

&lt;p&gt;条件是单峰的情况下,并且是asymmetrical类型(倾斜的数据)&lt;/p&gt;

&lt;h4&gt;Measuring the Dispersion of Data(度量数据的离散程度)&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Quartiles, outliers and boxplots（四分位数、离散点和盒图）

&lt;ul&gt;
&lt;li&gt;Inter-quartile range: IQR = Q3 – Q1;(Q1(25%),Q3(75%))&lt;/li&gt;
&lt;li&gt;Five number summary: min, Q1, M, Q3, max&lt;/li&gt;
&lt;li&gt;Boxplot(盒图):招不开了,见下&lt;/li&gt;
&lt;li&gt;Outlier: usually, a value higher/lower than 1.5 x IQR&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Variance and standard deviation (sample: s, population: σ)（方差和标准差）&lt;/li&gt;
&lt;li&gt;Properties of Normal Distribution Curve(正态分布特性)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Graphic Displays of Basic Statistical Descriptions(描述数据的基本图形)&lt;/h4&gt;

&lt;p&gt;Boxplot(盒图)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data is represented with a box(一个盒子来表示)&lt;/li&gt;
&lt;li&gt;The ends of the box are at the first and third quartiles, i.e., the height of the box is IRQ(上下边界分别是四分位点,即Q1和Q3,高度就是IRQ的高度了)&lt;/li&gt;
&lt;li&gt;The median is marked by a line within the box(中值在盒子里用一个线表示)&lt;/li&gt;
&lt;li&gt;Whiskers: two lines outside the box extend to Minimum and Maximum(盒子外两条线延伸到最大最小值)&lt;/li&gt;
&lt;li&gt;whiskers(上面两条线)长度不会大于1.5 * IRQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;来感受下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/Cpb7Fx.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Histogram Analysis(直方图)&lt;/p&gt;

&lt;p&gt;Quantile Plot(分位数图)&lt;/p&gt;

&lt;p&gt;Quantile-Quantile (Q-Q) Plot()(Q-Q图,横纵坐标都为分位数)&lt;/p&gt;

&lt;p&gt;Scatter plot（散点图）&lt;/p&gt;

&lt;p&gt;Loess (local regression) curve(回归曲线?): add a smooth curve to a scatter plot to provide better perception of the pattern of dependence&lt;/p&gt;

&lt;h3&gt;3 Data Cleaning&lt;/h3&gt;

&lt;p&gt;数据清理分以下几步:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;填充空缺的值&lt;/li&gt;
&lt;li&gt;识别孤立点&lt;/li&gt;
&lt;li&gt;消除噪声&lt;/li&gt;
&lt;li&gt;纠正数据中的不一致&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Missing Values(空缺数据)&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;忽略该元组(最常用的)&lt;/li&gt;
&lt;li&gt;人工填写空缺值: 量太大!&lt;/li&gt;
&lt;li&gt;使用一个全局常量填充空缺值: 将空缺的属性值用同一个常数(如“Unknown”或)替换。如果空缺值都用“Unknown”替换，当空缺值较多时。挖掘程序可能误以为它们形成了一个有趣的概念，因为它们都具有相同的值——“Unknown”。因此，尽管该方法简单，我们并不推荐它。&lt;/li&gt;
&lt;li&gt;使用属性的平均值填充空缺值&lt;/li&gt;
&lt;li&gt;利用同类别均值填补遗漏数据: 例如，如果将顾客按credit risk分类， 则用具有相同信用度的顾客的平均收入替换income中的缺值&lt;/li&gt;
&lt;li&gt;使用最可能的值填充空缺值:可以利用回归、贝叶斯计算公式或判定树归纳确定，推断出该条记录特定属性最大可能的取值。例如，利用数据集中其他顾客的属性，可以构造一棵判定树，来预测income的空缺值。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Noisy Data&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;binning(分箱)&lt;/strong&gt;: 分箱方法通过考察“邻居”(即周围的值)来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法参考相邻的值，因此它进行局部平滑。这里平滑方法又分了3种

&lt;ul&gt;
&lt;li&gt;按箱平均值平滑&lt;/li&gt;
&lt;li&gt;按箱中值平滑&lt;/li&gt;
&lt;li&gt;按箱边界平滑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clustering(聚类)&lt;/strong&gt;: 通过聚类分析可以检测孤立点，聚类将类似的值组织成群或“聚类”。直观地看，落在聚类集合之外的值被视为孤立点,这个方法在机器学习里有过了解.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;regression(回归)&lt;/strong&gt;: 以利用拟合函数(如回归函数)来平滑数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;4 Data Integration(数据集成)&lt;/h3&gt;

&lt;p&gt;它需要统一原始数据中的所有矛盾之处，如字段的:同名异义、异名同义、单位不统一,字长不一致，从而把原始数据在最低层上加以转换，提炼和集成。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;模式集成&lt;/strong&gt;: 通常，数据库和数据仓库有元数据——关于数据的数据。这种元数据可以帮助避免模式集成中的错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冗余问题&lt;/strong&gt;: 可以用概率的方法算出两个数据是相关还是独立,这种分析可以度量一个属性能在多大程度上蕴含另一个.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据值冲突的检测与处理&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;表示不同导致数据冲突&lt;/li&gt;
&lt;li&gt;语义不同导致数据冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于现实世界的同一实体，来自不同数据源的属性值可能不同。这可能是因为表示、比例或编码不同。例如，重量属性可能在一个系统中以公制单位存放，而在另一个系统中以英制单位存放。不同旅馆的价格不仅可能涉及不同的货币，而且可能涉及不同的服务(如免费早餐)和税。数据这种语义上的异种性，是数据集成的巨大挑战。&lt;/p&gt;

&lt;p&gt;将多个数据源中的数据集成起来，能够减少或避免结果数据集中数据的冗余和不一致性。这有助于提高其后挖掘的精度和速度。另外，在数据集成中还应考虑数据类型的选择问题，如在值域范围内应尽量用tinyint代替int, 可大大减少字节数，对于大规模数据集来说将会大大减少系统开销。&lt;/p&gt;

&lt;h3&gt;5 Data Transformation(数据变换)&lt;/h3&gt;

&lt;p&gt;数据变换将数据转换成适合于挖掘的形式。主要是找到数据的特征表示，对数据进行规格化处理。用维变换或转换方式减少有效变量的数目或找到数据的不变式.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;smoothing(平滑)&lt;/strong&gt;: 去掉数据中的噪声。这种技术包括分箱（Bin)、聚类和回归。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aggregation(聚集)&lt;/strong&gt;:对数据进行汇总和聚集例如，可以聚集日销售数据，计算月和年销售额。这一步用来为多粒度数据分析构造数据立方体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generalization(概化)&lt;/strong&gt;:使用概念分层，用高层次概念替换低层次“原始”数据。例如，分类的属性，如street，可以概化为较高层的概念，如city或country.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Normalization(规范化)&lt;/strong&gt;: 将属性数据按比例缩放，使之落入一个小的特定区间，如-1．0到1．0或0.0到1.0。规格化的目的是将一个属性取值范围影射到一个特定范围之内，以消除数值性属性因大小不一而造成挖掘结果的偏差.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attribute construction属性构造或特征构造&lt;/strong&gt;: 可以利用已知的属性构造新的属性并添加到属性集中，以帮助挖掘过程。(由长，宽求面积)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;7 Data Reduction(数据归约)&lt;/h3&gt;

&lt;p&gt;主要以下方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Data cube aggregation(数据方聚集):聚集操作用于数据方中的数据。主要用来构建数据立方.
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-10-11%2010:28:48%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;Atrribute subset selection(维归约):可以检测并删除不相关、弱相关或冗余的属性或维。(去除多余的属性值)&lt;/li&gt;
&lt;li&gt;Dimensionality reduction(数据压缩):使用编码机制压缩数据集。

&lt;ul&gt;
&lt;li&gt;discrete wavelet transform小波变换DWT&lt;/li&gt;
&lt;li&gt;principal components analysis 主要成分分析&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Numerosity reduction(数值压缩):用替代的、较小的数据表示替换或估计数据,如参数模型(只需要存放模型参数,而不是实际数据)或非参数方法,如&lt;strong&gt;聚类&lt;/strong&gt;、&lt;strong&gt;选样&lt;/strong&gt;和使用&lt;strong&gt;直方图&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Discretization and concept hierarchy generation(离散化和概念分层产生):属性的原始值用区间值或较高层的概念替换。概念分层允许挖掘多个抽象层上的数据,是数据挖掘的一种强有力的工具。
五种数值概念分层产生方法:

&lt;ul&gt;
&lt;li&gt;分箱&lt;/li&gt;
&lt;li&gt;直方图分析&lt;/li&gt;
&lt;li&gt;聚类分析&lt;/li&gt;
&lt;li&gt;基于熵的离散化&lt;/li&gt;
&lt;li&gt;通过“自然划分”的数据分段 :  &lt;strong&gt;3-4-5 规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Chapter 3 Data warehouse and OLAP technology:an overview(数据仓库和数据挖掘的 OLAP 技术)&lt;/h2&gt;
</content>
    </entry>
    

</feed>
