<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>Hackerxu's Blog</title>
    <subtitle>Python,HTML,CSS,Machine Leaning</subtitle>
    <link href="http://hackerxu.com/atom.xml" rel="self"/>
    <link href="http://hackerxu.com"/>
    <updated>2014-11-28T14:14:32+08:00</updated>
    <id>http://hackerxu.com</id>
    <author>
        <name>xuxiao</name>
    </author>
    
    <entry>
        <title>Python中的socket编程</title>
        <link href="http://hackerxu.com/2014/11/28/python_socket.html"/>
        <updated>2014-11-28T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/28/python_socket</id>
        <content type="html">&lt;p&gt;最近在看tornado源码,发现里面的tcp层会用到很多socket的知识,所以特地恶补一下.&lt;/p&gt;

&lt;h2&gt;1 socket基础&lt;/h2&gt;

&lt;h3&gt;1.1 socket 套接字&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;套接字 socket = (IP地址: 端口号)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这么简单,IP负责主机到主机(点到点)通讯,而端口号负责进程到进程(端到端)的通讯.python中socket编程在网络的应用层,涉及到些许运输层,所以极大简化了编程,我们只要对socket进行操作就可以了.&lt;/p&gt;

&lt;h3&gt;1.2 套接字家族&lt;/h3&gt;

&lt;p&gt;套接字起源于20世纪70年代加州大学伯克利分校版本的Unix，即人们所说的BSD Unix。因此，有时人们也把套接字称为“伯克利套接字”或“BSD套接字”。套接字有两种，分别是&lt;strong&gt;基于文件型&lt;/strong&gt;的和&lt;strong&gt;基于网络型&lt;/strong&gt;的。&lt;/p&gt;

&lt;h4&gt;基于文件型&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;或者&lt;code&gt;AF_LOCAL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;主要特点是两个进程都运行在同一台机器上，而且这些套接字是基于文件的,所以，它们的底层结构是由文件系统来支持的.&lt;/p&gt;

&lt;h4&gt;基于网络型&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;AF_INET&lt;/code&gt;或者&lt;code&gt;AF_INET6&lt;/code&gt;或者&lt;code&gt;AF_NETLINK&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;它们的特点是基于网络的,所有地址家族中，&lt;code&gt;AF_INET&lt;/code&gt;是使用最广泛的一个.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/TCP_IP.JPG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;1.3 面向连接与无连接&lt;/h3&gt;

&lt;p&gt;上面的图可以看到&lt;code&gt;AF_INET&lt;/code&gt;家族可以分为3种,我们常用的就两种TCP和UDP,对应的套接字类型为&lt;code&gt;SOCK_STREAM&lt;/code&gt;和&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;2 Python中网络编程&lt;/h2&gt;

&lt;p&gt;Python 提供了两个基本的 socket 模块。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个是 Socket，它提供了标准的 BSD Sockets API。&lt;/li&gt;
&lt;li&gt;第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2.1 socket()函数&lt;/h3&gt;

&lt;p&gt;在Python里我们用socket（）函数来创建套接字.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket(socket_family, socket_type, protocol=0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;socket_family: 套接字家族可以使AF_UNIX或者AF_INET&lt;/li&gt;
&lt;li&gt;socket_type: 套接字类型可以根据是面向连接的还是非连接分为&lt;code&gt;SOCK_STREAM&lt;/code&gt;或&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;protocol: 一般不填默认为0.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2.2 套接字对象(内建)方法&lt;/h3&gt;

&lt;p&gt;下面是经常用到的套接字方法:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务器端套接字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.bind()&lt;/td&gt;
&lt;td&gt;绑定地址(主机号,端口号)到套接字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.listen()&lt;/td&gt;
&lt;td&gt;开始TCP监听&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.accept()&lt;/td&gt;
&lt;td&gt;被动接受TCP客户端连接,(阻塞式)等待连接的到来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端套接字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.connect()&lt;/td&gt;
&lt;td&gt;主动初始化TCP服务器连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.connect_ex()&lt;/td&gt;
&lt;td&gt;connect()函数的扩展版本,出错时返回出错码,而不是抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;公共用途的套接字函数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.recv()&lt;/td&gt;
&lt;td&gt;接收TCP数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.send()&lt;/td&gt;
&lt;td&gt;发送TCP数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.sendall()&lt;/td&gt;
&lt;td&gt;完整发送TCP数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.recvform()&lt;/td&gt;
&lt;td&gt;接收UDP数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.sendto()&lt;/td&gt;
&lt;td&gt;发送UDP数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.close()&lt;/td&gt;
&lt;td&gt;关闭套接字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;2.3 客户端和服务器编程&lt;/h3&gt;

&lt;h4&gt;server&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建socket对象。调用socket构造函数。如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket = socket.socket( family, type )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将socket绑定到指定地址。这是通过socket对象的bind方法来实现的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket.bind( address ) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由AF_INET所创建的套接字，address地址必须是一个双元素元组，格式是(host,port)。host代表主机，port代表端口号。如果端口号正在使用、主机名不正确或端口已被保留，bind方法将引发socket.error异常。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用socket套接字的listen方法接收连接请求。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket.listen( backlog )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;backlog指定最多允许多少个客户连接到服务器。它的值至少为1。收到连接请求后，这些请求需要排队，如果队列满，就拒绝请求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器套接字通过socket的accept方法等待客户请求一个连接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;connection, address = socket.accept()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用accept方法时，socket会时入“waiting”状态。客户请求连接时，方法建立连接并返回服务器。accept方法返回一个含有两个元素的 元组(connection,address)。第一个元素connection是新的socket对象，服务器必须通过它与客户通信；第二个元素 address是客户的Internet地址。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理阶段，服务器和客户端通过send和recv方法通信(传输 数据)。服务器调用send，并采用字符串形式向客户发送信息。send方法返回已发送的字符个数。服务器使用recv方法从客户接收信息。调用recv 时，服务器必须指定一个整数，它对应于可通过本次方法调用来接收的最大数据量。recv方法在接收数据时会进入“blocked”状态，最后返回一个字符 串，用它表示收到的数据。如果发送的数据量超过了recv所允许的，数据会被截短。多余的数据将缓冲于接收端。以后调用recv时，多余的数据会从缓冲区 删除(以及自上次调用recv以来，客户可能发送的其它任何数据)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传输结束，服务器调用socket的close方法关闭连接。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;client&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个socket以连接服务器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket = socket.socket( family, type )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用socket的connect方法连接服务器。对于AF_INET家族,连接格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;socket.connect( (host,port) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;host代表服务器主机名或IP，port代表服务器进程所绑定的端口号。如连接成功，客户就可通过套接字与服务器通信，如果连接失败，会引发socket.error异常。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理阶段，客户和服务器将通过send方法和recv方法通信。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传输结束，客户通过调用socket的close方法关闭连接。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;代码&lt;/h4&gt;

&lt;p&gt;server:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------import------------------------------------&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;阻塞方式进行连接,当客户端退出继续监听,等待下一个客户端连接&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21568&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BUFSIZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ADDR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tcpSerSock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tcpSerSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tcpSerSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;waiting for connection...&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcpSerSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 等待连接&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;...connected from:&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUFSIZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 接收数据&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;[&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;] &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 发送数据&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;disconnect from:&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 退出&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tcpSerSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;############################################################################&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------import------------------------------------&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;只进行一次连接,输入`close`后退出程序&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21568&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BUFSIZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ADDR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 套接字连接&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;close&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 发送数据&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUFSIZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 接受数据&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tcpCliSock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 退出&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;############################################################################&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/&quot;&gt;python_socket 网络编程 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/jasonm2008/article/details/3964065&quot;&gt;TCP/IP 地址家族 ，协议类型 ，套接字类型 ，协议字段!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yangrong.blog.51cto.com/6945369/1339593&quot;&gt;python socket编程详细介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openexperience.iteye.com/blog/145701&quot;&gt;一个简单的python socket编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>new和init</title>
        <link href="http://hackerxu.com/2014/11/27/new_init.html"/>
        <updated>2014-11-27T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/27/new_init</id>
        <content type="html">&lt;p&gt;许多人认为&lt;code&gt;__init()__&lt;/code&gt;方法是类的构造方法,其实不然.&lt;code&gt;__init__()&lt;/code&gt;方法所做的工作是在类的对象创建好之后进行变量的初始化.&lt;code&gt;__new__()&lt;/code&gt;方法才会真正创建实例,是类的构造方法.这两个方法都是object类中默认的方法,继承自object的新式类,如果不覆盖这两个方法将会默认调用object中对应的方法.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__new__()&lt;/code&gt;和&lt;code&gt;__init()__&lt;/code&gt;的定义:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;object.__new__(cls[,args...])&lt;/code&gt;:其中cls代表类,args为参数列表.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.__init__(self[,args...])&lt;/code&gt;:其中self代表实例对象,args为参数列表.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同之处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__new__()&lt;/code&gt;方法为静态方法,&lt;code&gt;__init__()&lt;/code&gt;方法为实例方法.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__new__()&lt;/code&gt;方法一般需要返回类的对象,当返回类的对象时将会自动调用&lt;code&gt;__init__()&lt;/code&gt;方法进行初始化,如果没有对象返回,则&lt;code&gt;__init__()&lt;/code&gt;方法不会被调用.&lt;code&gt;__init__()&lt;/code&gt;方法不需要显示返回,默认为None,否则会在运行时抛出TypeError.&lt;/li&gt;
&lt;li&gt;当需要控制实例创建的时候可使用&lt;code&gt;__new__()&lt;/code&gt;方法,而控制实例初始化的时候用&lt;code&gt;__init__()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;一般情况下不需要覆盖&lt;code&gt;__new__()&lt;/code&gt;方法,但当子类继承自不可变类型,如str,int,unicode或者tuple的时候,往往需要覆盖该方法.&lt;/li&gt;
&lt;li&gt;当需要覆盖&lt;code&gt;__new__()&lt;/code&gt;和&lt;code&gt;__init()__&lt;/code&gt;方法的时候这两个方法的参数必须保持一致,如果不一致将导致异常.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;__new__()&lt;/code&gt;方法很少可以用到,有以下几种情况:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当类继承(如str,int,unicode,tuple或者forzenset等)不可变类型且默认的&lt;code&gt;__new__()&lt;/code&gt;方法不能满足需求的时候.&lt;/li&gt;
&lt;li&gt;用来实现工厂模式或者单例模式或者进行元类编程的时候.&lt;/li&gt;
&lt;li&gt;作为用来初始化的&lt;code&gt;__init__()&lt;/code&gt;方法在多继承的情况下,子类的&lt;code&gt;__init__()&lt;/code&gt;方法如果不显式调用父类的&lt;code&gt;__init__()&lt;/code&gt;方法,则父类的&lt;code&gt;__init__()&lt;/code&gt;方法不会被调用.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;new方法举例&lt;/h3&gt;

&lt;p&gt;举个工厂模式的例子:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;triangle&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;rectangle&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;klass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;creating a new shape &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;creating a new shape &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;I am a triangle&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;proint&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;I am drawing triangle&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rectangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;I am a rectangle&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;proint&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;I am drawing tectangle&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ShapeFactory类中重新覆盖了&lt;code&gt;__new__()&lt;/code&gt;方法,外界通过调用该方法来创建其所需要的对象类型,但如果所请求的类是系统所不支持的,则返回Shape对象.在引入了工厂类之后,只需要用如下形式就可以创建不同的图形对象:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;rectangle&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个继承不可变类型的例子:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;frozenset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;basestring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;frozenset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;I am testing&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;frozenset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;I am testing&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;UserSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;frozenset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意:为什么举这个例子呢,因为我们&lt;code&gt;print UserSet(&amp;quot;I am testing&amp;quot;)&lt;/code&gt;输出的是实例的值,而不是&lt;code&gt;__init__()&lt;/code&gt;的值,所以必须在&lt;code&gt;__new__()&lt;/code&gt;过程中(生成实例时)进行更改,才能输出我们想要的值.&lt;/p&gt;

&lt;p&gt;在UserSet中加入下面的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;basestring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;UserSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;am&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;frozenset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;I&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;实例化一个类的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查是否有&lt;code&gt;__new__()&lt;/code&gt;方法,如果没有就继承父类的&lt;code&gt;__new__()&lt;/code&gt;方法;如果有则用自己的&lt;code&gt;__new__()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;__new__()&lt;/code&gt;方法有返回值(类实例)则调用&lt;code&gt;__init__()&lt;/code&gt;方法;如果没有则不掉用.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实&lt;code&gt;__new__()&lt;/code&gt;方法就是构造函数,是这个类实例的构造(实例参数类型),而&lt;code&gt;__init__()&lt;/code&gt;方法是对实例初值进行赋值.大多数情况下我们可以用&lt;code&gt;__init__()&lt;/code&gt;完成任务,但是上面那几种情况就需要&lt;code&gt;__new__()&lt;/code&gt;方法.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use &lt;code&gt;__new__&lt;/code&gt; when you need to control the creation of a new instance. Use &lt;code&gt;__init__&lt;/code&gt; when you need to control initialization of a new instance.
&lt;code&gt;__new__&lt;/code&gt; is the first step of instance creation. It&amp;#39;s called first, and is responsible for returning a new instance of your class. In contrast, &lt;code&gt;__init__&lt;/code&gt; doesn&amp;#39;t return anything; it&amp;#39;s only responsible for initializing the instance after it&amp;#39;s been created.
In general, you shouldn&amp;#39;t need to override &lt;code&gt;__new__&lt;/code&gt; unless you&amp;#39;re subclassing an immutable type like str, int, unicode or tuple.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;From: &lt;a href=&quot;http://mail.python.org/pipermail/tutor/2008-April/061426.html&quot;&gt;http://mail.python.org/pipermail/tutor/2008-April/061426.html&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>为什么要有type和object?</title>
        <link href="http://hackerxu.com/2014/11/26/type_object.html"/>
        <updated>2014-11-26T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/26/type_object</id>
        <content type="html">&lt;p&gt;图片来源 &lt;a href=&quot;http://wiki.woodpecker.org.cn/moin/PyTypesAndObjects&quot;&gt;http://wiki.woodpecker.org.cn/moin/PyTypesAndObjects&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/types_map.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;先解释一下图片,虚线表示一个对象的type(类型),实线表示一个对象的base(基类/父类).&lt;/p&gt;

&lt;p&gt;这个图片很有意思的一个地方是&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;之间的关系,可以看到&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;是&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;的基类,而&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;是&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;的type(类型),这到底为什么?(这里先拿新式类来说,旧式类后面在说.)&lt;/p&gt;

&lt;p&gt;我觉得最主要的原因是来源于Python &lt;strong&gt;一切皆为对象&lt;/strong&gt; 的概念,在Python中所有的类或实例(比如list,int,1,&amp;#39;abc&amp;#39;)都是对象.&lt;/p&gt;

&lt;p&gt;如果要你设计会怎么设计?那就是设计一个超类,所有的对象的超集都是一个&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;类(也就是图上的&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;),即所有的对象都继承这个object类.这就是&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;类的由来.&lt;/p&gt;

&lt;p&gt;再看看&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;是怎么来的.看图,先撇开&lt;code&gt;metaclasses&lt;/code&gt;,来看右边两个矩形.可以看出对象分两种:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;classes(类)&lt;/li&gt;
&lt;li&gt;instances(实例)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;类和实例有什么关系呢?类创造了实例,而不是继承关系.那么问题来了,是什么创造了类呢?于是在Python里引进了&lt;code&gt;metaclasses&lt;/code&gt;,&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;就是元类,它可以创建类.记住 &lt;strong&gt;Python中的一切都是对象，它们要么是类的实例，要么是元类的实例&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;这样我们就统一了对象的创建,所有的对象都是&lt;code&gt;metaclasses&lt;/code&gt;创建的,而所有的对象都是&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;的子集,这就是为什么我们分别需要&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;object&lt;/code&gt;这两个东西~~最后,&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;之间的实线部分,那是因为 &lt;strong&gt;一切皆为对象&lt;/strong&gt; ,所以&lt;code&gt;type&lt;/code&gt;自然是&lt;code&gt;object&lt;/code&gt;的子集了.&lt;/p&gt;

&lt;p&gt;总之, &lt;strong&gt;&lt;code&gt;type&lt;/code&gt;是所有对象的妈或者奶奶,创建所有对象(包括自己,它的&lt;code&gt;__class__&lt;/code&gt;为&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;),&lt;code&gt;object&lt;/code&gt;是所有对象的祖宗(不包括自己,它的&lt;code&gt;__base__&lt;/code&gt;为空),所有对象继承祖宗的血统&lt;/strong&gt; ,就酱紫.&lt;/p&gt;

&lt;p&gt;ps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能通过形式上判断类的类型,应当从元类的类型来确定:古典类的元类为&lt;code&gt;types.ClassType&lt;/code&gt;,新式类的元类为&lt;code&gt;type&lt;/code&gt;,可以通过设置&lt;code&gt;__metaclass__&lt;/code&gt;来设置一个类的元类.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type(*)&lt;/code&gt;等同于&lt;code&gt;*.__class__&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个对象都有class，并且等于该对象的type.&lt;/li&gt;
&lt;li&gt;每个类(classes)或者type有bases属性，而实例(instances)则没有.只有&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;的bases是空的.&lt;/li&gt;
&lt;li&gt;要通过子类化构建对象,我们使用class关键字，并指定新对象的基类bases (或者可选的 type) . 这样通常创建出的是type object.&lt;/li&gt;
&lt;li&gt;要通过实例化构建对象, 需要使用在类对象上使用调用操作符即小括号 (())&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于上一个问题可以引出为什么要加入新式类?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 旧式类&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 新式类&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设a,b分别是类A,类B的实例,则:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对象&lt;/th&gt;
&lt;th&gt;&lt;code&gt;type&amp;lt;*&amp;gt;&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;*.__class__&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;*.__bases__&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;isinstance(*, object)&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;isinstance(*, type)&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;,)&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;instance&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;,)&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;可以看到对于旧式类,它的&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;*.__class__&lt;/code&gt;还有&lt;code&gt;*.__bases__&lt;/code&gt;比较混乱,而新式类就是为了解决这个问题,做到了大一统.&lt;/p&gt;

&lt;p&gt;新式类有很多优势:基于内建类型构建新的用户类型,支持property和描述符特性等.作为新式类的祖先,Object类中还定义了一些特殊方法,如:&lt;code&gt;__new__()&lt;/code&gt;,&lt;code&gt;__init__()&lt;/code&gt;,&lt;code&gt;__delattr__()&lt;/code&gt;,&lt;code&gt;__getattribute__()&lt;/code&gt;,&lt;code&gt;__setattr__()&lt;/code&gt;,&lt;code&gt;__hash__()&lt;/code&gt;,&lt;code&gt;__repr__()&lt;/code&gt;,&lt;code&gt;__str__()&lt;/code&gt;等等.Object的子类可以对这些方法进行覆盖以满足自身的特殊需求.&lt;/p&gt;

&lt;p&gt;另外，新式类和旧式类还有一个区别就是在多继承的时候，查找要调用的方法。新式类是广度优先的查找算法。旧式类的查找方法是深度优先的.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>回调函数(callback)</title>
        <link href="http://hackerxu.com/2014/11/22/callback.html"/>
        <updated>2014-11-22T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/22/callback</id>
        <content type="html">&lt;p&gt;回调函数其实一个很简单的概念,前几天突然看到这个概念一时间摸不到头脑.&lt;/p&gt;

&lt;p&gt;假如你开发个爬虫,要把它做成非阻塞异步的模式,而且你事先不知道如何爬取,你会怎么做呢?最好的方法是把每个页面和函数一一对应,然后每个页面都有自己的抓取规则,这样程序就知道对应的网页该如何处理了,把它放到线程(进程)池,再做异步处理,这就是&lt;code&gt;scrapy&lt;/code&gt;处理的方式.&lt;/p&gt;

&lt;p&gt;下面是scrapy的小demo(&lt;a href=&quot;https://github.com/taizilongxu/scrapy_jingdong/blob/master/tutorial/spiders/jd_spider.py&quot;&gt;源代码&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JdSpider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scrapy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Spider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;allowed_domains&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;jd.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start_urls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;quot;http://wap.jd.com/category/all.html&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;获取全部分类商品&amp;#39;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/html/body/div[5]/div[2]/a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;@href&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;category&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;http://wap.jd.com&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 回调函数用来指定特定页面的操作.对应的是self.parse_category函数&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;获取分类页&amp;#39;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/html/body/div[5]/div/a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;@href&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;http://wap.jd.com&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 回调函数&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到Request里每一个url对应一个callback,我们要做的就是把url和提取规则联系起来交给scrapy处理.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/question/19801131&quot;&gt;这里&lt;/a&gt;是知乎的答案,长篇大论的写了很多,但是饶了很多弯子.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>Zsh使用指南(译)</title>
        <link href="http://hackerxu.com/2014/11/19/ZSH.html"/>
        <updated>2014-11-19T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/19/ZSH</id>
        <content type="html">&lt;p&gt;原文:&lt;a href=&quot;http://code.joejag.com/2014/why-zsh.html&quot;&gt;http://code.joejag.com/2014/why-zsh.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zsh,因为其强大的shell交互功能已经被许多开发者所使用.虽然我也刚开始入门,但希望大家也一起加入Zsh的行列.&lt;/p&gt;

&lt;p&gt;自从我刚开始接触shell的时候就慢慢维护着自己的&lt;a href=&quot;https://github.com/joejag/dotfiles&quot;&gt;bash配置&lt;/a&gt;.为了用起来顺手收集了许多tab补全,别名和一些功能.当Zsh慢慢在博客,评论里流行的时候我已经在我的bash文件里进行了配置.但是我仍然有些质疑.&lt;/p&gt;

&lt;p&gt;然后我发现了&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh&lt;/a&gt;.一个集合了许多Zsh默认配置的项目.如果你们还没有接触过Zsh,那么相信你看完下面的介绍会毫不犹豫的更改你的shell.&lt;/p&gt;

&lt;h3&gt;背景&lt;/h3&gt;

&lt;p&gt;如果你对Bash比较习惯并且担心会丢失所有Bash知识,那么大可不必担心,99%的操作Bash和Zsh都是相同的.你可以很好的完成shell的转换.&lt;/p&gt;

&lt;p&gt;这篇文章使用的Zsh version 5.0.2和最近的oh-my-zsh.我在它们安装后没有做任何配置.&lt;/p&gt;

&lt;p&gt;在例子中用&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;来表示敲击tab键,别傻乎乎的打出来~&lt;/p&gt;

&lt;h3&gt;&amp;#39;cd&amp;#39;中tab补全&lt;/h3&gt;

&lt;p&gt;让我们从最常用的出发.改变当前目录.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/cd_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在Bash里当你按下&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;你会得到当前目录下的文件.&lt;/p&gt;

&lt;p&gt;这种情况下你只能进入到目录里,对于其他上下文来说并不是太有用.Zsh知道这点,它只给你显示有效的文件目录.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/cd_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;他不仅可以帮你匹配目录,而且还可以允许你用方向键进行选取.(&lt;code&gt;&amp;lt;TAB&amp;gt;向后,&amp;lt;Shift+TAB&amp;gt;向前&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;对于TAB智能补全和用按键进行选择交互这种方式是Zsh简单易用的核心.&lt;/p&gt;

&lt;h3&gt;快速&amp;#39;ls&amp;#39;&lt;/h3&gt;

&lt;p&gt;不必输入整个目录的名字,只需要输入几个能唯一识别的字母就可以了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/ls_shorthand_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;吡!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/ls_shorthand_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;清除历史&lt;/h3&gt;

&lt;p&gt;你可能熟悉使用&lt;code&gt;&amp;lt;CTRL&amp;gt;+R&lt;/code&gt;命令来寻找你使用过的命令.在Bash和Zsh中这是非常方便的方法.&lt;/p&gt;

&lt;p&gt;Zsh有一个更好的方法.你可以输入一部分命令然后按&lt;code&gt;&amp;lt;UP&amp;gt;&lt;/code&gt;键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/history_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;它会找他你最近用过的以&lt;code&gt;ls&lt;/code&gt;开始的命令.还可以继续寻找前面的命令.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/history_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;分享命令历史&lt;/h3&gt;

&lt;p&gt;在每个shell里Bash都有它自己的输入历史.但是在Zsh里它所有活动shell里都会有一个共同的历史.所以你就不用不得不记住你在哪里输入这个命令了.&lt;/p&gt;

&lt;h3&gt;扩展环境变量&lt;/h3&gt;

&lt;p&gt;在我们的shell里提供了环境变量.有些时候我们要使用这些变量值或者只是检查一下它们.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/path_expansion_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在Zsh里你可以按&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;键使这些变量转换成它们所表达的值.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/path_expansion_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;kill命令的tab补全&lt;/h3&gt;

&lt;p&gt;我通常用&lt;code&gt;kill&lt;/code&gt;前先使用&lt;code&gt;ps&lt;/code&gt;命令检查它们的进程号,或者当我确认的时候用&lt;code&gt;pkill&lt;/code&gt;命令,Zsh给你另一种方法.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/kill_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在输入&lt;code&gt;kill&lt;/code&gt;命令后,按&lt;code&gt;tab&lt;/code&gt;键它会提供一个以当前输入字母为开始的程序列表,通过方向键你可以选择杀掉哪个进程.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/kill_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;命令参数&lt;/h3&gt;

&lt;p&gt;当想要了解一个命令的时候你通常需要输入&lt;code&gt;-help&lt;/code&gt;或者检查&lt;code&gt;man page&lt;/code&gt;.Zsh提供了更好的方法.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/switch_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;-&lt;/code&gt;然后按&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/switch_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;它会列出选项和说明.你也可以用方向键进行选择.&lt;/p&gt;

&lt;p&gt;它步进在&lt;code&gt;ls&lt;/code&gt;命令中,他可以.它可以工作在像&lt;code&gt;netstat&lt;/code&gt;,&lt;code&gt;git&lt;/code&gt;,&lt;code&gt;chmod&lt;/code&gt;等大量的命令中.&lt;/p&gt;

&lt;h3&gt;Git辅助&lt;/h3&gt;

&lt;p&gt;每个人都有自己喜欢的&lt;code&gt;git&lt;/code&gt;命令的别名.oh-my-zsh给出了一大堆默认别名.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/git_aliases.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;当你进入一个git目录的时候它也会有提示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/git_prompt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;你可以查看它所在的分支名,上面的小叉号提示我有没有提交的更改.&lt;/p&gt;

&lt;h3&gt;上一个失败命令&lt;/h3&gt;

&lt;p&gt;你可能注意到了在截屏里的绿色小箭头.提示我上个命令运行成功.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/fail_prompt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果命令不成功提示符就会变成红色,直到命令运行成功.&lt;/p&gt;

&lt;h3&gt;匹配&lt;/h3&gt;

&lt;p&gt;在Bash里我通常用&lt;code&gt;find&lt;/code&gt;搭配&lt;code&gt;xargs&lt;/code&gt;命令去寻找文件.Zsh内建对这一功能的支持.&lt;/p&gt;

&lt;p&gt;让我们看看这个项目里的文件,而我要找到今天修改的文件.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_time_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们只需要在&lt;code&gt;ls&lt;/code&gt;后面加入一个模式匹配符就可以得到我们想要的了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_time_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;另一个比较实用的技巧是使用&lt;code&gt;**&lt;/code&gt;可以递归查找.我要在目录下寻找Rakefile.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_recursive.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;让我们加一个修饰符来递归查找大于20mb的文件.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_large_files.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个方法不止限于&lt;code&gt;ls&lt;/code&gt;.在这个项目里查找有多少行Clojure代码.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_wc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;让我们递归的删除在这个项目里的所有Clojure文件.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_rm_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;恩.但是我不太确信这个命令.所以让我们按&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;列出所有文件来代替.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/glob_rm_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;键入错误名字&lt;/h3&gt;

&lt;p&gt;经常我们忘了文件名字的大小写,或者错误的输入了文件名的中间部分而不是开头.Zsh能察觉到并帮我们自动的修改.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/autocorrect_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Zsh修改&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/autocorrect_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;有用的别名&lt;/h3&gt;

&lt;p&gt;除了git的别名,oh-my-zsh提供了许多有用的别名.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/cd_aliases.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;...&lt;/code&gt;帮你移到两层目录外真是太棒了.&lt;/p&gt;

&lt;h3&gt;Tabs named after the running process&lt;/h3&gt;

&lt;p&gt;Having the tab name changed to be the same as the running process is useful when you are hunting down where you are running that server.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/tab_names.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;在Vim里编辑长命令&lt;/h3&gt;

&lt;p&gt;你可以在Bash和Zsh里用&lt;code&gt;&amp;lt;CTRL&amp;gt;+k&lt;/code&gt;在长命令里来删除字符(我这里怎么是&lt;code&gt;&amp;lt;CTRL&amp;gt;+h&lt;/code&gt;?).但是有时候你想用功能更强大的编辑器来写长命令.&lt;/p&gt;

&lt;p&gt;可以按&lt;code&gt;&amp;lt;CTRL&amp;gt;+X &amp;lt;CTRL&amp;gt;+E&lt;/code&gt;把当前命令放到你的&lt;code&gt;$EDITOR&lt;/code&gt;里.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/vim_mode_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;温馨的&lt;code&gt;$EDITOR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/vim_mode_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们可以编辑命令保存然后就会退回到终端里.&lt;/p&gt;

&lt;h3&gt;工具插件&lt;/h3&gt;

&lt;p&gt;oh-my-zsh有一个为工具提供的插件的列表.我用rake插件可以允许你用&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;进入在你Rakefile里的rake命令.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/rake_before.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;双击&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;可以进入可以选择的列表.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/rake_after.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;仅此而已?&lt;/h3&gt;

&lt;p&gt;我直到最近才发现Zsh真他娘的好用啊.原因如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tab补全和选择&lt;/li&gt;
&lt;li&gt;活跃的插件社区提供我们基本的dotfile&lt;/li&gt;
&lt;li&gt;Bash中99%的东西都能用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你准备好用zsh了吗?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/chsh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>HTTPS协议</title>
        <link href="http://hackerxu.com/2014/11/18/HTTPS.html"/>
        <updated>2014-11-18T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/18/HTTPS</id>
        <content type="html">&lt;h2&gt;HTTPS简介&lt;/h2&gt;

&lt;p&gt;它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。&lt;/p&gt;

&lt;p&gt;它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安全全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话用户可以确认发送者是谁。&lt;/p&gt;

&lt;h2&gt;HTTPS图示&lt;/h2&gt;

&lt;p&gt;HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2011082417242348.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;1 客户端发起HTTPS请求&lt;/h4&gt;

&lt;p&gt;这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。&lt;/p&gt;

&lt;h4&gt;2 服务端的配置&lt;/h4&gt;

&lt;p&gt;采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。&lt;/p&gt;

&lt;h4&gt;3 传送证书&lt;/h4&gt;

&lt;p&gt;这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。&lt;/p&gt;

&lt;h4&gt;4 客户端解析证书&lt;/h4&gt;

&lt;p&gt;这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。&lt;/p&gt;

&lt;h4&gt;5 传送加密信息&lt;/h4&gt;

&lt;p&gt;这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。&lt;/p&gt;

&lt;h4&gt;6 服务段解密信息&lt;/h4&gt;

&lt;p&gt;服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。&lt;/p&gt;

&lt;h4&gt;7 传输加密后的信息&lt;/h4&gt;

&lt;p&gt;这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。&lt;/p&gt;

&lt;h4&gt;8 客户端解密信息&lt;/h4&gt;

&lt;p&gt;客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。&lt;/p&gt;

&lt;h2&gt;HTTPS和HTTP的区别&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-24%2021:11:23%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;https协议需要到ca申请证书，一般免费证书很少，需要交费。&lt;/li&gt;
&lt;li&gt;http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议&lt;/li&gt;
&lt;li&gt;http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。&lt;/li&gt;
&lt;li&gt;http的连接很简单,是无状态的&lt;/li&gt;
&lt;li&gt;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为用HTTPS协议需要对传送数据进行加密解密,所以一定会影响速度和性能,所以一般只有银行等关键位置才会设置HTTPS.&lt;/p&gt;

&lt;h2&gt;Q&amp;amp;A&lt;/h2&gt;

&lt;h4&gt;如果中间的路由从双方发送证书的时候就开始监听的话呢，是否就可以窃取内容了？&lt;/h4&gt;

&lt;p&gt;否，服务器那边有一个非对称密钥加密系统，首先他将公开密钥发送给客户端，客户端接收之后为会话创建一个pre-master secret(一个用在对称加密密钥生成中的 46 字节的随机数字)，然后用服务器发送过来的公开密钥加密，然后将加密后的内容发送给服务器，这两个阶段，如果有人监听，即使窃取到也没办法，首先公开密钥对所有人其实都是公开的，用公开密钥加密后的内容是非常非常难解密的，只有用服务器自己有的私有密钥解密才可以。服务器获取到46字节的随机数字之后，通过这个来对将来要发送的加密内容加密，而这个解密方法之后对应的那个客户端才知道，钥匙是通过公开密钥加密的，其他人都不知道，所有就保证了内容的安全性。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/yufaw/article/details/8515889&quot;&gt;http://blog.csdn.net/yufaw/article/details/8515889&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>HTTP协议</title>
        <link href="http://hackerxu.com/2014/11/17/HTTP.html"/>
        <updated>2014-11-17T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/17/HTTP</id>
        <content type="html">&lt;h1&gt;1 基础概念&lt;/h1&gt;

&lt;p&gt;HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。&lt;/p&gt;

&lt;p&gt;HTTP协议的主要特点可概括如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持客户/服务器模式。&lt;/li&gt;
&lt;li&gt;简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;1.1 URI&lt;/h3&gt;

&lt;p&gt;URI统一资源标识符(Unicform Resource Identifier):唯一标识并定位信息资源.它有两个子集,一个是URL(Unicform Resource Locator),另一个是URN(Unicform Resource Name)&lt;/p&gt;

&lt;h4&gt;1.1.1 URL&lt;/h4&gt;

&lt;p&gt;URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;http://host[&amp;quot;:&amp;quot;port][abs_path]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;http表示要通过HTTP协议来定位网络资源；&lt;/li&gt;
&lt;li&gt;host表示合法的Internet主机域名或者IP地址；&lt;/li&gt;
&lt;li&gt;port指定一个端口号，为空则使用缺省端口80；&lt;/li&gt;
&lt;li&gt;abs_path指定请求资源的URI；&lt;/li&gt;
&lt;li&gt;如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入：www.guet.edu.cn
浏览器自动转换成：&lt;a href=&quot;http://www.guet.edu.cn/&quot;&gt;http://www.guet.edu.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;http:192.168.0.116:8080/index.jsp&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;1.1.2 URN&lt;/h4&gt;

&lt;p&gt;URN：URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。&lt;/p&gt;

&lt;h3&gt;1.2 层次关系&lt;/h3&gt;

&lt;p&gt;HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/5657919_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;默认HTTP的端口号为80，HTTPS的端口号为443。&lt;/p&gt;

&lt;h3&gt;1.3 HTTP的请求响应模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-12.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;HTTP协议永远都是客户端发起请求，服务器回送响应。&lt;/p&gt;

&lt;p&gt;这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端&lt;/p&gt;

&lt;p&gt;HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。&lt;/p&gt;

&lt;h3&gt;1.4 工作流程&lt;/h3&gt;

&lt;p&gt;一次HTTP操作称为一个事务，其工作过程可分为四步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。&lt;/li&gt;
&lt;li&gt;建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。&lt;/li&gt;
&lt;li&gt;服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。&lt;/li&gt;
&lt;li&gt;客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。&lt;/p&gt;

&lt;h3&gt;1.5 查看HTTP&lt;/h3&gt;

&lt;p&gt;我们可以在chrome的审查元素里查看network,也可以用firefox的LiveHTTP插件,下面是访问&lt;code&gt;www.baidu.com&lt;/code&gt;返回的http:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
DNT: 1
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2

HTTP/1.1 200 OK
Date: Sun, 16 Nov 2014 06:43:47 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: Keep-Alive
Vary: Accept-Encoding
Set-Cookie: BAIDUID=53D3052AEE1A2972D5AED1E505323E95
Cache-Control: private
Cxy_all: baidu+8e65b23e6d5bd3877ec23fa1c478e07c
Expires: Sun, 16 Nov 2014 06:42:56 GMT
X-Powered-By: HPHP
Server: BWS/1.1
BDPAGETYPE: 1
BDQID: 0xfa409b4000452dee
BDUSERID: 0
Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到,HTTP协议的请求消息和响应消息有固定的格式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;-------------------------请求头格式------------------------------------------------------------------
HTTP请求行 
（请求）头 
空行 
可选的消息体 
---------------------------响应头格式----------------------------------------------------------------
HTTP状态行 
（应答）头 
空行 
可选的消息体
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;2 HTTP报文&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-24%2020:43:24%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;2.1 HTTP请求报文(request message)&lt;/h2&gt;

&lt;p&gt;HTTP协议的请求主要由一下几部分组成：请求行，请求头，请求体（post）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;请求行\r\n
请求头1\r\n
请求头1\r\n
...
\r\n
请求体（Post方式）\r\n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.1.1 请求行&lt;/h4&gt;

&lt;p&gt;请求行主要由三部分组成，请求方法，请求路径，请求协议.例如上面的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的HTTP方法:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否包含主体&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;从服务器获取一份文档&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;只从服务器获取文档首部&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向服务器发送需要处理的数据&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;将请求的主体部分存储在服务器上&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;对可能经过代理服务器传送到服务器上去的报文进行追踪&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;决定可以在服务器上执行那些方法&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;从服务器删除一份文档&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;还有一种CONNECT,已文档化但当前未实现的一个方法，预留做隧道处理&lt;/p&gt;

&lt;p&gt;当然我们最常用的也就是get和post方法，get方法的请求方式比较简单，所有请求的参数都显示追加在请求的url后面，而且请求长度有限制，post方式的请求参数都追加在请求体当中，消息长度没有限制而且以隐式的方式进行发送，安全性相对较高（这个安全性对于现在的网络技术也没有什么可安全的了，^_^）。&lt;/p&gt;

&lt;p&gt;请求路径：请求路径可以是相对或者绝对的方式，绝对路径不去阐述，相对路径是相对于当前TCP连接的主机的路径（HTTP/1.0方式），在HTTP/1.1方式当中相对于的是请求头当中的host域，HTTP/1.1的新特性会在以后的方式当中进行阐述&lt;/p&gt;

&lt;p&gt;请求协议：目前常用的支持HTTP/1.0和HTTP/1.1方式，HTTP/1.1和HTTP/1.0之间存在不少差异性，&lt;/p&gt;

&lt;h3&gt;2.1.2 请求头&lt;/h3&gt;

&lt;p&gt;比如上面的例子中:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
DNT: 1
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求头都是以key:value形式进行保存的，里面记录了客户端的一些基本信息，常用的请求头如下所示.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Host:客户端IP和端口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host: www.baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;User-Agent:浏览器信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept：客户端能接收的数据类型&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept-Encoding: gzip,deflate,sdch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-charset：客户端字符编码集&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Content-Length：表示请求消息正文的长度。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cookie：这是最重要的请求头信息之一。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Referer: http://www.baidu.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;2.1.3 请求体&lt;/h3&gt;

&lt;p&gt;请求体（又叫请求正文）是post请求方式当中的请求参数,get方式则无请求体，以key=value形式进行存储，多个请求参数之间用&amp;amp;连接，如果请求当中有请求提，那么在请求头当中的Content-Length属性中记录的是该请求体的长度。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;POST hysj.jsp HTTP/1.1
Host: search.cnipr.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; zh-CN; rv:1.9.1.13) Gecko/20100914 Firefox/3.5.13 ( .NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp
Content-Length: 405
username=guest&amp;amp;extension=&amp;amp;issearch=on&amp;amp;searchword=pd%3D%2820100901%29&amp;amp;presearchword=&amp;amp;sortfield=RELEVANCE&amp;amp;sRecordNumber=&amp;amp;searchType=0&amp;amp;searchFrom=0&amp;amp;channelid=14%2C15%2C16&amp;amp;searchChannel=14%2C15%2C16&amp;amp;strdb=14&amp;amp;strdb=15&amp;amp;strdb=16&amp;amp;cizi=2&amp;amp;sortcolumn=RELEVANCE&amp;amp;R1=-&amp;amp;txtA=&amp;amp;txtB=&amp;amp;txtC=&amp;amp;txtD=20100901&amp;amp;txtE=&amp;amp;txtF=&amp;amp;txtG=&amp;amp;txtH=&amp;amp;txtI=&amp;amp;txtJ=&amp;amp;txtK=&amp;amp;txtL=&amp;amp;txtM=&amp;amp;txtN=&amp;amp;txtP=&amp;amp;txtQ=&amp;amp;txtR=&amp;amp;txtSearchWord=&amp;amp;Submit=%BC%EC%A1%A1%CB%F7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 HTTP响应报文(response message)&lt;/h2&gt;

&lt;p&gt;HTTP响应信息(服务器信息) &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;状态行：HTTP版本  服务器状态(比如：404找不到...) 描述信息&lt;/li&gt;
&lt;li&gt;响应头&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  content-text：服务器发送信息的类型
  date：发送时间
  server：服务器类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;消息体：服务器发送给客户端的页面内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP响应的格式类似于请求的格式，主要由响应行，响应头，响应体组成，其格式如下所示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;响应行\r\n
响应头\r\n
响应头\r\n
...

响应体
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.1 响应行&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标识服务器端对客户端请求的处理结果，主要由响应状态信息，响应状态码，服务器协议.&lt;/p&gt;

&lt;p&gt;响应状态信息:HTTP协议&lt;/p&gt;

&lt;p&gt;状态代码分类:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;整体范围&lt;/th&gt;
&lt;th&gt;已定义范围&lt;/th&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100 ~ 199&lt;/td&gt;
&lt;td&gt;100 ~ 101&lt;/td&gt;
&lt;td&gt;信息提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;200 ~ 299&lt;/td&gt;
&lt;td&gt;200 ~ 206&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300 ~ 399&lt;/td&gt;
&lt;td&gt;300 ~ 305&lt;/td&gt;
&lt;td&gt;重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400 ~ 499&lt;/td&gt;
&lt;td&gt;400 ~ 415&lt;/td&gt;
&lt;td&gt;客户端错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;500 ~ 599&lt;/td&gt;
&lt;td&gt;500 ~ 505&lt;/td&gt;
&lt;td&gt;服务器错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;响应状态码:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消息（1字头）:这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;100 继续
101 分组交换协
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成功（2字头）:这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;200 OK
201 被创建
202 被采纳
203 非授权信息
204 无内容
205 重置内容
206 部分内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重定向（3字头）:这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;300 多选项
301 永久地传送
302 找到
303 参见其他
304 未改动
305 使用代理
307 暂时重定向
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请求错误（4字头）:这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;400 错误请求
401 未授权
402 要求付费
403 禁止
404 未找到
405 不允许的方法
406 不被采纳
407 要求代理授权
408 请求超时
409 冲突
410 过期的
411 要求的长度
412 前提不成立
413 请求实例太大
414 请求URI太大
415 不支持的媒体类型
416 无法满足的请求范围
417 失败的预期
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器错误（5字头）:这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;500 内部服务器错误
501 未被使用
502 网关错误
503 不可用的服务
504 网关超时
505 HTTP版本未被支持
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的状态码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.2 响应头&lt;/h4&gt;

&lt;p&gt;类似于请求头的key：value形式，常用响应头如下所示:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Location:这个头通常配合302状态码使用，它用于告诉浏览器你去找谁。 &lt;/li&gt;
&lt;li&gt;Server：告诉浏览器，服务器的类型 &lt;/li&gt;
&lt;li&gt;Content-Encoding: 服务器通过这个头，告诉浏览器，回送的数据采用的压缩格式。 &lt;/li&gt;
&lt;li&gt;Content-Length: 80 &lt;/li&gt;
&lt;li&gt;Content-Language: zh-cn &lt;/li&gt;
&lt;li&gt;Content-Type：这个头用于告诉浏览器，回送数据的类型 &lt;/li&gt;
&lt;li&gt;Last-Modified：这个头用于告诉浏览器，数据的最后修改时间 &lt;/li&gt;
&lt;li&gt;Refresh: ：这个头用于控制浏览器定时刷新 &lt;/li&gt;
&lt;li&gt;Content-Disposition: 用于通知浏览器，以下载方式打开回送的数据 &lt;/li&gt;
&lt;li&gt;Transfer-Encoding: 用于通知浏览器，数据是以分块形式回送的 &lt;/li&gt;
&lt;li&gt;ETag: 缓存相头的头 &lt;/li&gt;
&lt;li&gt;Expires: 用于说明网页的失效时间，如果该值为一个&lt;code&gt;&amp;lt;0&lt;/code&gt;的值，则服务器是通知浏览器不要缓存 &lt;/li&gt;
&lt;li&gt;Cache-Control: no-cache  通知浏览器不要缓存 &lt;/li&gt;
&lt;li&gt;Pragma: no-cache&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面只是简单介绍了下,如需详细还需要查阅手册.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://t.cn/R7FguRq&quot;&gt;HTTP权威指南&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;3 wireshark抓包查看HTTP过程&lt;/h1&gt;

&lt;p&gt;下面是打开&lt;code&gt;www.baidu.com&lt;/code&gt;所有的包:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;No.     Time           Source                Destination           Protocol Length Info
    355 4.170229000    222.26.7.125          119.75.217.56         TCP      74     50536 &amp;gt; http [SYN] Seq=0 Win=29200 Len=0 MSS=1460 SACK_PERM=1 TSval=7178795 TSecr=0 WS=128
    356 4.183233000    119.75.217.56         222.26.7.125          TCP      74     http &amp;gt; 50536 [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0 MSS=1440 SACK_PERM=1 WS=128
    357 4.183284000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=1 Ack=1 Win=29312 Len=0
    358 4.183343000    222.26.7.125          119.75.217.56         HTTP     131    GET / HTTP/1.1 
    359 4.196633000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [ACK] Seq=1 Ack=78 Win=24704 Len=0
    360 4.199425000    119.75.217.56         222.26.7.125          TCP      943    [TCP segment of a reassembled PDU]
    361 4.199454000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=890 Win=32128 Len=0
    362 4.199635000    119.75.217.56         222.26.7.125          TCP      1494   [TCP segment of a reassembled PDU]
    363 4.199652000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=2330 Win=35072 Len=0
    364 4.199766000    119.75.217.56         222.26.7.125          TCP      1494   [TCP segment of a reassembled PDU]

...

    475 4.217795000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=82970 Win=184192 Len=0
    476 4.217832000    119.75.217.56         222.26.7.125          HTTP     556    HTTP/1.1 200 OK  (text/html)
    477 4.217835000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=83472 Win=183808 Len=0
    478 4.218827000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [FIN, ACK] Seq=78 Ack=83472 Win=185856 Len=0
    479 4.232403000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [ACK] Seq=83472 Ack=79 Win=24704 Len=0
    480 4.232442000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [FIN, ACK] Seq=83472 Ack=79 Win=24704 Len=0
    481 4.232468000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=79 Ack=83473 Win=185856 Len=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以清楚的看到HTTP的详细过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;355,356,357是三次握手的过程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后浏览器发送HTTP请求,其实这次请求是夹在第三次握手的包中的,可以看到HTTP包的详细信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Transmission Control Protocol, Src Port: 50536 (50536), Dst Port: http (80), Seq: 1, Ack: 1, Len: 77
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的seq=1,所以它是来自上一个TCP包.因为HTTP是由TCP包包装成的,所以这里显示的HTTP包其实是前面的TCP包的解包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来是一连串由服务器发来的TCP包和浏览器确认TCP包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直到476浏览器请求的所有TCP包都被接受,这时TCP按照序号把所有TCP包拆解并组成HTTP包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;478~481最后4个为4次挥手.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/CareySon/archive/2012/04/27/HTTP-Protocol.html&quot;&gt;http://www.cnblogs.com/CareySon/archive/2012/04/27/HTTP-Protocol.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.360doc.com/content/10/0930/17/3668821_57590979.shtml&quot;&gt;http://www.360doc.com/content/10/0930/17/3668821_57590979.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/linzheng/archive/2011/01/25/1944914.html&quot;&gt;http://www.cnblogs.com/linzheng/archive/2011/01/25/1944914.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>TCP三次握手和四次挥手</title>
        <link href="http://hackerxu.com/2014/11/16/TCP.html"/>
        <updated>2014-11-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/16/TCP</id>
        <content type="html">&lt;p&gt;上周终于面了知乎,结果跪了~一是基础还不怎么扎实,二是没有准备,原以为能在12月分面试呢,结果发完题过两天就发了面试通知,不过知乎的态度真的不错,面了一个半点,虽然大多数问的问题都能知道,但是平时都没深入了解,所以今天总结一下TCP协议.&lt;/p&gt;

&lt;h2&gt;TCP图示&lt;/h2&gt;

&lt;p&gt;TCP(Transmission Control Protocol)传输控制协议.&lt;/p&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/ae52f886642e0019fa0973268eeb08b4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;TCP状态&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/375102e721925d18e6ac4e994a5ace8f.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面图中白色部分是TCP协议的字段,可以看到TCP的flag有6个,着重介绍下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;URG:紧急URG,当URG置为1时,发送应用进程就告诉发送方的TCO有紧急数据发送,于是发送方TCP就把紧急数据插入到&lt;strong&gt;本报文段数据的最前面&lt;/strong&gt;.*(例如用户从键盘发出中断命令,如果不使用紧急数据那么这个命令就会放在TCO的缓存末尾,这样浪费很多时间)&lt;/li&gt;
&lt;li&gt;ACK:当ACK=1时&lt;code&gt;Acknowledgment Number&lt;/code&gt;才有效.(仅在三次握手第一次握手时ACK=0,其他时刻ACK都为1)&lt;/li&gt;
&lt;li&gt;PSH:操作很少用到,当接受方TCP接受到PSH=1的报文段,就尽快的PUSH给接收应用进程,而不再等待整个缓存都填满后再向上交付.&lt;/li&gt;
&lt;li&gt;RST:当RST=1时说明发生了严重错误,必须释放连接,然后重新建立运输连接.&lt;/li&gt;
&lt;li&gt;SYN:连接建立时的同步信号,后面会说.&lt;/li&gt;
&lt;li&gt;FIN:释放连接,后面会说.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;三次握手&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次握手:
客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327002911.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次握手:
服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003054.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次握手.
客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003214.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在wireshark上看一下包的传递,下面以解析百度首页为例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2010:38:22%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以清楚的看到前三个包就是三次握手的TCP包,所有包中有用信息都在info里,再来解释下其他字段含义:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Win:窗口字段明确指出&lt;strong&gt;现在&lt;/strong&gt;允许&lt;strong&gt;对方&lt;/strong&gt;发送的数据量(经常变化)&lt;/li&gt;
&lt;li&gt;Len:暂时未知,TCP字段未有这个关键字?&lt;/li&gt;
&lt;li&gt;MSS(Maximum Segment Size):最大报文段长度,即每个TCP报文段中的数据字段的最大长度.这里需要在握手的时候进行协商,双方都给出MSS,最后以最小MSS确定为最终的MSS.IP数据报最大传输单位为MTU(Maximum Transmission Unit，Effect of short board),对于大多数使用以太网的局域网来说，MTU=1500。MSS往往基于MTU计算出来，通常MSS=MTU-sizeof(IP Header)-sizeof(TCP Header)=1500-20-20=1460,这里我们看到服务器MSS=1460,而客户端的MSS=1440,所以最终为1440.&lt;/li&gt;
&lt;li&gt;SACK_PERM:选择确认字段,如果中间缺少包而其他包都已经接收,那么直接传送缺少包.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三次握手和其他数据传输包没有区别,原因是这个包是为了改变服务器状态,使服务器从半连接状态转换为全连接状态.&lt;/p&gt;

&lt;h2&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/u=220219588,1869709485&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。&lt;/li&gt;
&lt;li&gt;服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。&lt;/li&gt;
&lt;li&gt;服务器B关闭与客户端A的连接，发送一个FIN给客户端A。&lt;/li&gt;
&lt;li&gt;客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在来看看百度的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2011:54:51%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;其实第2,4部和普通的数据传输包没有区别,关键是第1,3个FIN包,它们告诉对方自己将不传送信息,只接受信息.所以TCP的四次挥手可以看成是&lt;strong&gt;两个二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;为什么采用3次握手而不是2次握手?&lt;/h4&gt;

&lt;p&gt;如果两次握手的话,客户端有可能因为网络阻塞等原因会发送多个请求报文,这时服务器就会建立连接,浪费掉许多服务器的资源.&lt;/p&gt;

&lt;h4&gt;为什么建立连接是三次握手，而关闭连接却是四次挥手呢？&lt;/h4&gt;

&lt;p&gt;这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。&lt;/p&gt;

&lt;h4&gt;为什么在四次挥手中A在TIME-WAIT状态必须等待2MSL的时间?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;为了保证A发送的最后一个ACK报文能到达B.&lt;/li&gt;
&lt;li&gt;防止&amp;quot;已失效的连接请求报文段&amp;quot;,2MSL过后网络中没有此次连接的报文,可以进行下一个连接.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后TCP有限状态机:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/39b9724c51eec0a4380d0ca5e44cb227.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cppblog.com/csolay/archive/2011/10/22/158859.aspx&quot;&gt;http://www.cppblog.com/csolay/archive/2011/10/22/158859.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-7411781-id-3812206.html&quot;&gt;http://blog.chinaunix.net/uid-7411781-id-3812206.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.2cto.com/net/201208/149347.html&quot;&gt;http://www.2cto.com/net/201208/149347.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>粒子群算法(转)</title>
        <link href="http://hackerxu.com/2014/11/14/PSO.html"/>
        <updated>2014-11-14T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/14/PSO</id>
        <content type="html">&lt;p&gt;本文整理自: &lt;a href=&quot;http://blog.csdn.net/niuyongjie/article/details/1569671&quot;&gt;http://blog.csdn.net/niuyongjie/article/details/1569671&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;粒子群算法简介&lt;/h1&gt;

&lt;h2&gt;1 粒子群算法的历史&lt;/h2&gt;

&lt;p&gt;粒子群算法源于复杂适应系统（Complex Adaptive System,CAS）。CAS理论于1994年正式提出，CAS中的成员称为主体。比如研究鸟群系统，每个鸟在这个系统中就称为主体。主体有适应性，它能够与环境及其他的主体进行交流，并且根据交流的过程“学习”或“积累经验”改变自身结构与行为。整个系统的演变或进化包括：新层次的产生（小鸟的出生）；分化和多样性的出现（鸟群中的鸟分成许多小的群）；新的主题的出现（鸟寻找食物过程中，不断发现新的食物）。&lt;/p&gt;

&lt;p&gt;所以CAS系统中的主体具有4个基本特点（这些特点是粒子群算法发展变化的依据）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，主体是主动的、活动的。&lt;/li&gt;
&lt;li&gt;主体与环境及其他主体是相互影响、相互作用的，这种影响是系统发展变化的主要动力。&lt;/li&gt;
&lt;li&gt;环境的影响是宏观的，主体之间的影响是微观的，宏观与微观要有机结合。&lt;/li&gt;
&lt;li&gt;最后，整个系统可能还要受一些随机因素的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粒子群算法就是对一个CAS系统－－－鸟群社会系统的研究得出的。&lt;/p&gt;

&lt;p&gt;粒子群算法（ Particle Swarm Optimization, PSO）最早是由Eberhart和Kennedy于1995年提出，它的基本概念源于对鸟群觅食行为的研究。设想这样一个场景:一群鸟在随机搜寻食物，在这个区域里只有一块食物，所有的鸟都不知道食物在哪里，但是它们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢?最简单有效的就是搜寻目前离食物最近的鸟的周围区域。&lt;/p&gt;

&lt;p&gt;PSO算法就从这种生物种群行为特性中得到启发并用于求解优化问题。在PSO中，每个优化问题的潜在解都可以想象成d维搜索空间上的一个点，我们称之为“粒子”（Particle），所有的粒子都有一个被目标函数决定的适应值(Fitness Value )，每个粒子还有一个速度决定他们飞翔的方向和距离，然后粒子们就追随当前的最优粒子在解空间中搜索。Reynolds对鸟群飞行的研究发现。鸟仅仅是追踪它有限数量的邻居但最终的整体结果是整个鸟群好像在一个中心的控制之下.即复杂的全局行为是由简单规则的相互作用引起的。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的具体表述&lt;/h2&gt;

&lt;p&gt;上面罗嗦了半天，那些都是科研工作者写论文的语气，不过，PSO的历史就像上面说的那样。下面通俗的解释PSO算法。&lt;/p&gt;

&lt;p&gt;PSO算法就是模拟一群鸟寻找食物的过程，每个鸟就是PSO中的粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，不停改变自己在空中飞行的位置与速度。大家也可以观察一下，鸟群在寻找食物的过程中，开始鸟群比较分散，逐渐这些鸟就会聚成一群，这个群忽高忽低、忽左忽右，直到最后找到食物。这个过程我们转化为一个数学问题。寻找函数&lt;code&gt;y=1-cos(3*x)*exp(-x)&lt;/code&gt;的在[0,4]最大值。该函数的图形如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_hanshutuxing.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;当x=0.9350-0.9450，达到最大值y=1.3706。为了得到该函数的最大值，我们在[0，4]之间随机的洒一些点，为了演示，我们放置两个点，并且计算这两个点的函数值，同时给这两个点设置在[0，4]之间的一个速度。下面这些点就会按照一定的公式更改自己的位置，到达新位置后，再计算这两个点的值，然后再按照一定的公式更新自己的位置。直到最后在y=1.3706这个点停止自己的更新。这个过程与粒子群算法作为对照如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这两个点就是粒子群算法中的粒子。&lt;/li&gt;
&lt;li&gt;该函数的最大值就是鸟群中的食物 &lt;/li&gt;
&lt;li&gt;计算两个点函数值就是粒子群算法中的适应值，计算用的函数就是粒子群算法中的适应度函数。&lt;/li&gt;
&lt;li&gt;更新自己位置的一定公式就是粒子群算法中的位置速度更新公式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面演示一下这个算法运行一次的大概过程：&lt;/p&gt;

&lt;p&gt;第一次初始化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi1.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi2.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi3.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第21次更新:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi4.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后的结果（30次迭代）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi5.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后所有的点都集中在最大值的地方。&lt;/p&gt;

&lt;p&gt;在粒子群算法的大概思想就说到这里。下节介绍标准的粒子群算法.&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法&lt;/h1&gt;

&lt;p&gt;在上一节的叙述中，唯一没有给大家介绍的就是函数的这些随机的点（粒子）是如何运动的，只是说按照一定的公式更新。这个公式就是粒子群算法中的位置速度更新公式。下面就介绍这个公式是什么。在上一节中我们求取函数y=1-cos(3*x)*exp(-x)的在[0,4]最大值。并在[0,4]之间放置了两个随机的点，这些点的坐标假设为$x_1=1.5$；$ x_2=2.5$；这里的点是一个标量，但是我们经常遇到的问题可能是更一般的情况－－x为一个矢量的情况，比如二维的情$况 z=2*x_1+3*x_2$的情况。这个时候我们的每个粒子为二维，记粒$子P_1＝(x_{11},x_{12}),P2=(x_{21},x_{22}),P3=(x_{31},x_{32})，......Pn=(x_{n1},x_{n2})$。这里n为粒子群群体的规模，也就是这个群中粒子的个数，每个粒子的维数为2。更一般的是粒子的维数为q，这样在这个种群中有n个粒子，每个粒子为q 维。&lt;/p&gt;

&lt;p&gt;由n个粒子组成的群体对Q维（就是每个粒子的维数）空间进行搜索。每个粒子表示为：$xi＝（x_{i1},x_{i2},x_{i3},...,x_{iQ}）$，每个粒子对应的速度可以表示为$vi=(v_{i1},v_{i2},v_{i3},....,v_{iQ})$，每个粒子在搜索时要考虑两个因素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自己搜索到的历史最优值 $p_i ，p_i=(p_{i1},p_{i2},....,p_{iQ})$，i=1,2,3,....,n。&lt;/li&gt;
&lt;li&gt;全部粒子搜索到的最优值$p_g，p_g=(p_{g1},p_{g2},....,p_{gQ})$，注意这里的$p_g$只有一个。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面给出粒子群算法的位置速度更新公式：&lt;/p&gt;

&lt;p&gt;$$v_{id}^{k+1} = wv_{id}^{k} + c_1\xi(p_{id}^k - x_{id}^k) + c_2\eta(p_{gd}^{k} - x_{id}^k)$$&lt;/p&gt;

&lt;p&gt;$$x_{id}^{k+1} = x_{id}^{k} + rv_{id}^{k+1}$$&lt;/p&gt;

&lt;p&gt;这里有几个重要的参数需要大家记忆，因为在以后的讲解中将会经常用到,它们是：&lt;/p&gt;

&lt;p&gt;$w$是保持原来速度的系数，所以叫做&lt;strong&gt;惯性权重&lt;/strong&gt;。
$c_1$是粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，所以叫“&lt;strong&gt;认知&lt;/strong&gt;”。通常设置为2。
$\xi$  $\eta$是[0,1]区间内均匀分布的随机数。
$r$是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做&lt;strong&gt;约束因子&lt;/strong&gt;。通常设置为1。&lt;/p&gt;

&lt;p&gt;这样一个标准的粒子群算法就结束了。&lt;/p&gt;

&lt;p&gt;下面对整个基本的粒子群的过程给一个简单的图形表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_liucheng.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;判断终止条件可是设置适应值到达一定的数值或者循环一定的次数。&lt;/p&gt;

&lt;p&gt;注意：这里的粒子是同时跟踪自己的历史最优值与全局（群体）最优值来改变自己的位置预速度的，所以又叫做&lt;strong&gt;全局版本的标准粒子群优化算法&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法(局部版本)&lt;/h1&gt;

&lt;p&gt;在全局版的标准粒子群算法中，每个粒子的速度的更新是根据两个因素来变化的，这两个因素是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子群体的全局最优值$p_g$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果改变粒子速度更新公式，让每个粒子的速度的更新根据以下两个因素更新，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子&lt;strong&gt;邻域内&lt;/strong&gt;粒子的最优值$pn_k$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其余保持跟全局版的标准粒子群算法一样，这个算法就变为局部版的粒子群算法。&lt;/p&gt;

&lt;p&gt;一般一个粒子i 的邻域随着迭代次数的增加而逐渐增加，开始第一次迭代，它的邻域为0，随着迭代次数邻域线性变大，最后邻域扩展到整个粒子群，这时就变成全局版本的粒子群算法了。经过实践证明：全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在&lt;strong&gt;收敛速度与摆脱局部最优&lt;/strong&gt;这两个方面下功夫。其实这两个方面是矛盾的。看如何更好的折中了。&lt;/p&gt;

&lt;p&gt;根据取邻域的方式的不同，局部版本的粒子群算法有很多不同的实现方法.&lt;/p&gt;

&lt;p&gt;第一种方法：按照粒子的编号取粒子的邻域，取法有四种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;环形取法 
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_huan.bmp&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机环形取法
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_shuan.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;轮形取法 
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_lun.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机轮形取法。
&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_slun.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为后面有以环形取法实现的算法，对环形取法在这里做一点点说明：以粒子1为例，当邻域是0的时候，邻域是它本身，当邻域是1时，邻域为2，8；当邻域是2时，邻域是2，3，7，8；......，以此类推，一直到邻域为4，这个时候，邻域扩展到整个例子群体。据文献介绍（&lt;strong&gt;国外的文献&lt;/strong&gt;），采用轮形拓扑结构，PSO的效果很好。&lt;/p&gt;

&lt;p&gt;第二种方法：按照粒子的欧式距离取粒子的邻域&lt;/p&gt;

&lt;p&gt;在第一种方法中，按照粒子的编号来得到粒子的邻域，但是这些粒子其实可能在实际位置上并不相邻，于是Suganthan提出基于空间距离的划分方案，在迭代中计算每一个粒子与群中其他粒子的距离。记录任何2个粒子间的的最大距离为dm。对每一粒子按照$||x_a-x_b||/dm$计算一个比值。其中||xa-xb||是当前粒子a到b的距离。而选择阈值frac根据迭代次数而变化。当另一粒子b满足$||x_a-x_b||/dm &amp;lt; frac$时，认为b成为当前粒子的邻域。&lt;/p&gt;

&lt;p&gt;这种办法经过实验，取得较好的应用效果，但是由于要计算所有粒子之间的距离，计算量大，且需要很大的存储空间，所以，&lt;strong&gt;该方法一般不经常使用&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;粒子群算法分类&lt;/h1&gt;

&lt;p&gt;粒子群算法主要分为4个大的分支：&lt;/p&gt;

&lt;h2&gt;1 标准粒子群算法的变形&lt;/h2&gt;

&lt;p&gt;在这个分支中，主要是对标准粒子群算法的惯性因子、收敛因子（约束因子）、“认知”部分的$c_1$，“社会”部分的$c_2$进行变化与调节，希望获得好的效果。&lt;/p&gt;

&lt;p&gt;惯性因子的原始版本是保持不变的，后来有人提出随着算法迭代的进行，惯性因子需要逐渐减小的思想。算法开始阶段，大的惯性因子可以使算法不容易陷入局部最优，到算法的后期，小的惯性因子可以使收敛速度加快，使收敛更加平稳，不至于出现振荡现象。&lt;strong&gt;经过本人测试&lt;/strong&gt;，动态的减小惯性因子w，的确可以使算法更加稳定，效果比较好。但是递减惯性因子采用什么样的方法呢？人们首先想到的是线型递减，这种策略的确很好，但是是不是最优的呢？于是有人对递减的策略作了研究，研究结果指出：线型函数的递减优于凸函数的递减策略，但是凹函数的递减策略又优于线型的递减，经过本人测试，实验结果基本符合这个结论，但是效果不是很明显。&lt;/p&gt;

&lt;p&gt;对于收敛因子，经过证明如果收敛因子取0.729,可以确保算法的收敛，但是不能保证算法收敛到全局最优，经过本人测试，取收敛因子为0.729效果较好。对于社会与认知的系数$c_1$,$c_2$也有人提出：$c_1$先大后小，而$c_2$先小后大的思想，因为在算法运行初期，每个鸟要有大的自己的认知部分而又比较小的社会部分，这个与我们自己一群人找东西的情形比较接近，因为在我们找东西的初期，我们基本依靠自己的知识取寻找，而后来，我们积累的经验越来越丰富，于是大家开始逐渐达成共识（社会知识），这样我们就开始依靠社会知识来寻找东西了。&lt;/p&gt;

&lt;p&gt;2007年希腊的两位学者提出将收敛速度比较快的全局版本的粒子群算法与不容易陷入局部最优的局部版本的粒子群算法相结合的办法，利用的公式是:&lt;/p&gt;

&lt;p&gt;速度更新公式，v代表速度&lt;/p&gt;

&lt;p&gt;$$ v＝n*v(全局版本)＋（1－n）*v(局部版本) $$&lt;/p&gt;

&lt;p&gt;位置更新公式&lt;/p&gt;

&lt;p&gt;$$w（k＋1）＝w(k)＋v$$&lt;/p&gt;

&lt;p&gt;该算法在文献中讨论了系数n取各种不同情况的情况，并且运行来了20000次来分析各种系数的结果。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的混合&lt;/h2&gt;

&lt;p&gt;这个分支主要是将粒子群算法与各种算法相混合，有人将它与模拟退火算法相混合，有些人将它与单纯形方法相混合。但是最多的是将它与遗传算法的混合。根据遗传算法的三种不同算子可以生成3中不同的混合算法。&lt;/p&gt;

&lt;h3&gt;粒子群算法与选择算子的结合&lt;/h3&gt;

&lt;p&gt;这里相混合的思想是：在原来的粒子群算法中，我们选择粒子群群体的最优值作为$p_g$，但是相结合的版本是根据所有粒子的适应度的大小给每个粒子赋予一个被选中的概率，然后依据概率对这些粒子进行选择，被选中的粒子作为$p_g$，其它的情况都不变。这样的算法可以在算法运行过程中保持粒子群的多样性，但是致命的缺点是收敛速度缓慢。&lt;/p&gt;

&lt;h3&gt;粒子群算法与杂交算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想与遗传算法的基本一样，在算法运行过程中根据适应度的大小，粒子之间可以两两杂交，比如用一个很简单的公式:&lt;/p&gt;

&lt;p&gt;$$w（新）＝n×w_1＋（1－n）×w_2$$&lt;/p&gt;

&lt;p&gt;w1与w2就是这个新粒子的父辈粒子。&lt;/p&gt;

&lt;p&gt;这种算法可以在算法的运行过程中引入新的粒子，但是算法一旦陷入局部最优，那么粒子群算法将很难摆脱局部最优。&lt;/p&gt;

&lt;h3&gt;粒子群算法与变异算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想：测试所有粒子与当前最优的距离，当距离小于一定的数值的时候，可以拿出所有粒子的一个百分比（如10％）的粒子进行随机初始化，让这些粒子重新寻找最优值。&lt;/p&gt;

&lt;h2&gt;3 二进制粒子群算法&lt;/h2&gt;

&lt;p&gt;最初的PSO是从解决连续优化问题发展起来的.Eberhart等又提出了PSO的离散二进制版.用来解决工程实际中的组合优化问题。他们在提出的模型中将粒子的每一维及粒子本身的历史最优、全局最优限制为1或0，而速度不作这种限制。用速度更新位置时，设定一个阈值，当速度高于该阈值时，粒子的位置取1，否则取0。二进制PSO与遗传算法在形式上很相似，但实验结果显示，在大多数测试函数中，二进制PSO比遗传算法速度快，尤其在问题的维数增加时.&lt;/p&gt;

&lt;h2&gt;4 协同粒子群算法&lt;/h2&gt;

&lt;p&gt;协同PSO，该方法将粒子的D维分到D个粒子群中，每个粒子群优化一维向量，评价适应度时将这些分量合并为一个完整的向量。例如第i个粒子群，除第i个分量外，其他D-1个分量都设为最优值，不断用第i个粒子群中的粒子替换第i个分量，直到得到第i维的最优值，其他维相同。为将有联系的分量划分在一个群，可将D维向量分配到m个粒子群优化，则前D mod m个粒子群的维数是D/m的向上取整。后m－(D mod m)个粒子群的维数是D/m的向下取整。协同PSO在某些问题上有更快的收敛速度，但该算法容易被欺骗。&lt;/p&gt;

&lt;p&gt;基本的粒子群算法的分支就着4个，大部分的粒子群算法都围绕着这4个分支在变化，其中粒子群算法的变形居多，从根本上来说，几乎没有什么新的思想的提出。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>协程</title>
        <link href="http://hackerxu.com/2014/11/08/Coroutine.html"/>
        <updated>2014-11-08T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/08/Coroutine</id>
        <content type="html">&lt;p&gt;知乎上的&lt;a href=&quot;http://www.zhihu.com/question/20511233&quot;&gt;这个&lt;/a&gt;答案很好,总结一下协程.&lt;/p&gt;

&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;

&lt;h2&gt;进程、线程和协程&lt;/h2&gt;

&lt;p&gt;进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。&lt;/p&gt;

&lt;p&gt;线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。&lt;/p&gt;

&lt;p&gt;协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;共享堆&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;共享栈&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;操作系统调度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;进程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;线程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;协程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h4&gt;与进程&amp;amp;线程的不同之处&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;操作系统内核不知道协程的存在&lt;/li&gt;
&lt;li&gt;协程不独享进程控制块和处理机时间片&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;与进程&amp;amp;线程的相同之处&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;协程的状态存在挂起、唤醒、死亡&lt;/li&gt;
&lt;li&gt;协程和协程之前有控制权的释放和获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。&lt;/p&gt;

&lt;h2&gt;协程的优势&lt;/h2&gt;

&lt;p&gt;最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。&lt;/p&gt;

&lt;p&gt;第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。&lt;/p&gt;

&lt;h2&gt;Python中的协程&lt;/h2&gt;

&lt;p&gt;一个实际一点的例子：thread.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python thread.py&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python -m gevent.monkey thread.py&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;threadA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threadB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;threadA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threadB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python thread.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你是均匀输出的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A
B
A
B
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么总共发生了 20 次切换：主线程 -&amp;gt; A -&amp;gt; B -&amp;gt; A -&amp;gt; B …&lt;/p&gt;

&lt;p&gt;再看一个协程的例子：gr.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python gr.py&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;greenletA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;greenletB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;greenletA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenletB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;greenlet 是 python 的协程实现。&lt;/p&gt;

&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python gr.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时发生了 2 次切换：主协程 -&amp;gt; A -&amp;gt; B&lt;/p&gt;

&lt;p&gt;可能你已经注意到了，还有一个命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python -m gevent.monkey thread.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gevent 是基于 greenlet 的一个 python 库，它可以把 python 的内置线程用 greenlet 包装，这样在我们使用线程的时候，实际上使用的是协程，在上一个协程的例子里，协程 A 结束时，由协程 A 让位给协程 B ，而在 gevent 里，所有需要让位的协程都让位给主协程，由主协程决定运行哪一个协程，gevent 也会包装一些可能需要阻塞的方法，比如 sleep ，比如读 socket ，比如等待锁，等等，在这些方法里会自动让位给主协程，而不是由程序员显示让位，这样程序员就可以按照线程的模式进行线性编程，不需要考虑切换的逻辑。&lt;/p&gt;

&lt;p&gt;假设代码质量相同，用原生的协程实现需要切换 n 次，用协程包装后的线程实现，就需要 2n - 1 次，姑且算是两倍吧。很显然，单纯从效率上来说，代码质量相同的前提下，用 gevent 永远也不可能比用 greenlet 快，然而，问题往往不那么单纯，比方说，单纯从效率上来说，代码质量相同的前提下，用 C 实现的程序永远不可能比汇编快。&lt;/p&gt;

&lt;p&gt;再来说说 python 的线程，python 的线程不是标准线程，在 python 中，一个进程内的多个线程只能使用一个 CPU 。&lt;/p&gt;

&lt;p&gt;重新来看一下协程和线程的区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。&lt;/p&gt;

&lt;p&gt;如果使用 gevent 包装后的线程，程序员就不必承担调度的责任，而 python 的线程本身就没有使用多 CPU 的能力，那么，用 gevent 包装后的线程，取代 python 的内置线程，不是只有避免无意义的调度，提高性能的好处，而没有什么坏处了吗？&lt;/p&gt;

&lt;p&gt;答案是否定的。举一个例子，有一个 GUI 程序，上面有两个按钮，一个 运算 一个 取消 ，点击运算，会有一个运算线程启动，不停的运算，点击取消，会取消这个线程，如果使用 python 的内置线程或者标准线程，都是没有问题的，即便运算线程不停的运算，调度器仍然会给 GUI 线程分配时间片，用户可以点击取消，然而，如果使用 gevent 包装后的线程就完蛋了，一旦运算开始，GUI 就会失去相应，因为那个运算线程(协程)霸着 CPU 不让位。不单是 GUI ，所有和用户交互的程序都会有这个问题。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tonyseek/introduce-to-coroutine/blob/master/docs/source/index.rst&quot;&gt;https://github.com/tonyseek/introduce-to-coroutine/blob/master/docs/source/index.rst&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000&quot;&gt;http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20511233&quot;&gt;http://www.zhihu.com/question/20511233&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    

</feed>
