<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>Hackerxu's Blog</title>
    <subtitle>Python,HTML,CSS,Machine Leaning</subtitle>
    <link href="http://hackerxu.com/atom.xml" rel="self"/>
    <link href="http://hackerxu.com"/>
    <updated>2014-11-16T21:16:26+08:00</updated>
    <id>http://hackerxu.com</id>
    <author>
        <name>xuxiao</name>
    </author>
    
    <entry>
        <title>HTTPS协议</title>
        <link href="http://hackerxu.com/2014/11/18/HTTPS.html"/>
        <updated>2014-11-18T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/18/HTTPS</id>
        <content type="html">&lt;h2&gt;HTTPS简介&lt;/h2&gt;

&lt;p&gt;它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。&lt;/p&gt;

&lt;p&gt;它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安全全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话用户可以确认发送者是谁。&lt;/p&gt;

&lt;h2&gt;HTTPS图示&lt;/h2&gt;

&lt;p&gt;HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2011082417242348.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;1 客户端发起HTTPS请求&lt;/h4&gt;

&lt;p&gt;这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。&lt;/p&gt;

&lt;h4&gt;2 服务端的配置&lt;/h4&gt;

&lt;p&gt;采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。&lt;/p&gt;

&lt;h4&gt;3 传送证书&lt;/h4&gt;

&lt;p&gt;这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。&lt;/p&gt;

&lt;h4&gt;4 客户端解析证书&lt;/h4&gt;

&lt;p&gt;这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。&lt;/p&gt;

&lt;h4&gt;5 传送加密信息&lt;/h4&gt;

&lt;p&gt;这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。&lt;/p&gt;

&lt;h4&gt;6 服务段解密信息&lt;/h4&gt;

&lt;p&gt;服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。&lt;/p&gt;

&lt;h4&gt;7 传输加密后的信息&lt;/h4&gt;

&lt;p&gt;这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。&lt;/p&gt;

&lt;h4&gt;8 客户端解密信息&lt;/h4&gt;

&lt;p&gt;客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。&lt;/p&gt;

&lt;h2&gt;HTTPS和HTTP的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;https协议需要到ca申请证书，一般免费证书很少，需要交费。&lt;/li&gt;
&lt;li&gt;http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议&lt;/li&gt;
&lt;li&gt;http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。&lt;/li&gt;
&lt;li&gt;http的连接很简单,是无状态的&lt;/li&gt;
&lt;li&gt;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为用HTTPS协议需要对传送数据进行加密解密,所以一定会影响速度和性能,所以一般只有银行等关键位置才会设置HTTPS.&lt;/p&gt;

&lt;h2&gt;Q&amp;amp;A&lt;/h2&gt;

&lt;h4&gt;如果中间的路由从双方发送证书的时候就开始监听的话呢，是否就可以窃取内容了？&lt;/h4&gt;

&lt;p&gt;否，服务器那边有一个非对称密钥加密系统，首先他将公开密钥发送给客户端，客户端接收之后为会话创建一个pre-master secret(一个用在对称加密密钥生成中的 46 字节的随机数字)，然后用服务器发送过来的公开密钥加密，然后将加密后的内容发送给服务器，这两个阶段，如果有人监听，即使窃取到也没办法，首先公开密钥对所有人其实都是公开的，用公开密钥加密后的内容是非常非常难解密的，只有用服务器自己有的私有密钥解密才可以。服务器获取到46字节的随机数字之后，通过这个来对将来要发送的加密内容加密，而这个解密方法之后对应的那个客户端才知道，钥匙是通过公开密钥加密的，其他人都不知道，所有就保证了内容的安全性。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/yufaw/article/details/8515889&quot;&gt;http://blog.csdn.net/yufaw/article/details/8515889&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>HTTP协议</title>
        <link href="http://hackerxu.com/2014/11/17/HTTP.html"/>
        <updated>2014-11-17T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/17/HTTP</id>
        <content type="html">&lt;h1&gt;基础概念&lt;/h1&gt;

&lt;p&gt;HTTP协议的主要特点可概括如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持客户/服务器模式。&lt;/li&gt;
&lt;li&gt;简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;HTTP的URL&lt;/h4&gt;

&lt;p&gt;http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。&lt;/p&gt;

&lt;p&gt;HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;http://host[&amp;quot;:&amp;quot;port][abs_path]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;http表示要通过HTTP协议来定位网络资源；&lt;/li&gt;
&lt;li&gt;host表示合法的Internet主机域名或者IP地址；&lt;/li&gt;
&lt;li&gt;port指定一个端口号，为空则使用缺省端口80；&lt;/li&gt;
&lt;li&gt;abs_path指定请求资源的URI；&lt;/li&gt;
&lt;li&gt;如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eg:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入：www.guet.edu.cn
浏览器自动转换成：&lt;a href=&quot;http://www.guet.edu.cn/&quot;&gt;http://www.guet.edu.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;http:192.168.0.116:8080/index.jsp &lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;1.1 层次关系&lt;/h3&gt;

&lt;p&gt;HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/5657919_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;默认HTTP的端口号为80，HTTPS的端口号为443。&lt;/p&gt;

&lt;h3&gt;1.2 HTTP的请求响应模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0-12.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;HTTP协议永远都是客户端发起请求，服务器回送响应。&lt;/p&gt;

&lt;p&gt;这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端&lt;/p&gt;

&lt;p&gt;HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。&lt;/p&gt;

&lt;h3&gt;1.3 工作流程&lt;/h3&gt;

&lt;p&gt;一次HTTP操作称为一个事务，其工作过程可分为四步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。&lt;/li&gt;
&lt;li&gt;建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。&lt;/li&gt;
&lt;li&gt;服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。&lt;/li&gt;
&lt;li&gt;客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。&lt;/p&gt;

&lt;h3&gt;1.4 查看HTTP&lt;/h3&gt;

&lt;p&gt;我们可以在chrome的审查元素里查看network,也可以用firefox的LiveHTTP插件,下面是访问&lt;code&gt;www.baidu.com&lt;/code&gt;返回的http:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
DNT: 1
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2

HTTP/1.1 200 OK
Date: Sun, 16 Nov 2014 06:43:47 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: Keep-Alive
Vary: Accept-Encoding
Set-Cookie: BAIDUID=53D3052AEE1A2972D5AED1E505323E95:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
Set-Cookie: BAIDUPSID=53D3052AEE1A2972D5AED1E505323E95; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
Set-Cookie: BDSVRTM=0; path=/
Set-Cookie: BD_HOME=0; path=/
Set-Cookie: H_PS_PSSID=9984_1445_9592_7800_9536_9476_9498_9770_9909_9758_9478_7798_9453_9978_9023; path=/; domain=.baidu.com
P3P: CP=&amp;quot; OTI DSP COR IVA OUR IND COM &amp;quot;
Cache-Control: private
Cxy_all: baidu+8e65b23e6d5bd3877ec23fa1c478e07c
Expires: Sun, 16 Nov 2014 06:42:56 GMT
X-Powered-By: HPHP
Server: BWS/1.1
BDPAGETYPE: 1
BDQID: 0xfa409b4000452dee
BDUSERID: 0
Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到,HTTP协议的请求消息和响应消息有固定的格式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;-------------------------请求头格式------------------------------------------------------------------
HTTP请求行 
（请求）头 
空行 
可选的消息体 
---------------------------响应头格式----------------------------------------------------------------
HTTP状态行 
（应答）头 
空行 
可选的消息体
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;HTTP请求&lt;/h2&gt;

&lt;p&gt;HTTP协议的请求主要由一下几部分组成：请求行，请求头，请求体（post）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;请求行\r\n
请求头1\r\n
请求头1\r\n
...
\r\n
请求体（Post方式）\r\n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;请求行&lt;/h4&gt;

&lt;p&gt;请求行主要由三部分组成，请求方法，请求路径，请求协议.例如上面的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求方法：HTTP规范定义了8种可能的请求方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GET  检索URI中标识资源的一个简单请求&lt;/li&gt;
&lt;li&gt;HEAD 与GET方法相同，服务器只返回状态行和头标，并不返回请求文档&lt;/li&gt;
&lt;li&gt;POST 服务器接受被写入客户端输出流中的数据的请求&lt;/li&gt;
&lt;li&gt;PUT 服务器保存请求数据作为指定URI新内容的请求&lt;/li&gt;
&lt;li&gt;DELETE 服务器删除URI中命名的资源的请求&lt;/li&gt;
&lt;li&gt;OPTIONS 关于服务器支持的请求方法信息的请求&lt;/li&gt;
&lt;li&gt;TRACE Web服务器反馈Http请求和其头标的请求&lt;/li&gt;
&lt;li&gt;CONNECT 已文档化但当前未实现的一个方法，预留做隧道处理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然我们最常用的也就是get和post方法，get方法的请求方式比较简单，所有请求的参数都显示追加在请求的url后面，而且请求长度有限制，post方式的请求参数都追加在请求体当中，消息长度没有限制而且以隐式的方式进行发送，安全性相对较高（这个安全性对于现在的网络技术也没有什么可安全的了，^_^）。&lt;/p&gt;

&lt;p&gt;请求路径：请求路径可以是相对或者绝对的方式，绝对路径不去阐述，相对路径是相对于当前TCP连接的主机的路径（HTTP/1.0方式），在HTTP/1.1方式当中相对于的是请求头当中的host域，HTTP/1.1的新特性会在以后的方式当中进行阐述&lt;/p&gt;

&lt;p&gt;请求协议：目前常用的支持HTTP/1.0和HTTP/1.1方式，HTTP/1.1和HTTP/1.0之间存在不少差异性，&lt;/p&gt;

&lt;h3&gt;请求头&lt;/h3&gt;

&lt;p&gt;比如上面的例子中:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
DNT: 1
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求头都是以key:value形式进行保存的，里面记录了客户端的一些基本信息，常用的请求头如下所示.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Host:客户端IP和端口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host: www.baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;User-Agent:浏览器信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept：客户端能接收的数据类型&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept-Encoding: gzip,deflate,sdch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-charset：客户端字符编码集&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,ja;q=0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Content-Length：表示请求消息正文的长度。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cookie：这是最重要的请求头信息之一。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Referer: http://www.baidu.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;请求体&lt;/h3&gt;

&lt;p&gt;请求体（又叫请求正文）是post请求方式当中的请求参数，以key=value形式进行存储，多个请求参数之间用&amp;amp;连接，如果请求当中有请求提，那么在请求头当中的Content-Length属性中记录的是该请求体的长度。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;POST hysj.jsp HTTP/1.1
Host: search.cnipr.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; zh-CN; rv:1.9.1.13) Gecko/20100914 Firefox/3.5.13 ( .NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp
Content-Length: 405
username=guest&amp;amp;extension=&amp;amp;issearch=on&amp;amp;searchword=pd%3D%2820100901%29&amp;amp;presearchword=&amp;amp;sortfield=RELEVANCE&amp;amp;sRecordNumber=&amp;amp;searchType=0&amp;amp;searchFrom=0&amp;amp;channelid=14%2C15%2C16&amp;amp;searchChannel=14%2C15%2C16&amp;amp;strdb=14&amp;amp;strdb=15&amp;amp;strdb=16&amp;amp;cizi=2&amp;amp;sortcolumn=RELEVANCE&amp;amp;R1=-&amp;amp;txtA=&amp;amp;txtB=&amp;amp;txtC=&amp;amp;txtD=20100901&amp;amp;txtE=&amp;amp;txtF=&amp;amp;txtG=&amp;amp;txtH=&amp;amp;txtI=&amp;amp;txtJ=&amp;amp;txtK=&amp;amp;txtL=&amp;amp;txtM=&amp;amp;txtN=&amp;amp;txtP=&amp;amp;txtQ=&amp;amp;txtR=&amp;amp;txtSearchWord=&amp;amp;Submit=%BC%EC%A1%A1%CB%F7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;HTTP响应&lt;/h2&gt;

&lt;p&gt;HTTP响应信息(服务器信息) &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;状态行：HTTP版本  服务器状态(比如：404找不到...) 描述信息&lt;/li&gt;
&lt;li&gt;响应头&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  content-text：服务器发送信息的类型
  date：发送时间
  server：服务器类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;消息体：服务器发送给客户端的页面内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP响应的格式类似于请求的格式，主要由响应行，响应头，响应体组成，其格式如下所示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;响应行\r\n
响应头\r\n
响应头\r\n
...

响应体
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;响应行&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标识服务器端对客户端请求的处理结果，主要由响应状态信息，响应状态码，服务器协议.&lt;/p&gt;

&lt;p&gt;响应状态信息:HTTP协议&lt;/p&gt;

&lt;p&gt;响应状态码:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消息（1字头）:这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;100 继续
101 分组交换协
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成功（2字头）:这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;200 OK
201 被创建
202 被采纳
203 非授权信息
204 无内容
205 重置内容
206 部分内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重定向（3字头）:这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;300 多选项
301 永久地传送
302 找到
303 参见其他
304 未改动
305 使用代理
307 暂时重定向
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请求错误（4字头）:这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;400 错误请求
401 未授权
402 要求付费
403 禁止
404 未找到
405 不允许的方法
406 不被采纳
407 要求代理授权
408 请求超时
409 冲突
410 过期的
411 要求的长度
412 前提不成立
413 请求实例太大
414 请求URI太大
415 不支持的媒体类型
416 无法满足的请求范围
417 失败的预期
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器错误（5字头）:这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;500 内部服务器错误
501 未被使用
502 网关错误
503 不可用的服务
504 网关超时
505 HTTP版本未被支持
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的状态码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;响应头&lt;/h4&gt;

&lt;p&gt;类似于请求头的key：value形式，常用响应头如下所示:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Location:这个头通常配合302状态码使用，它用于告诉浏览器你去找谁。 &lt;/li&gt;
&lt;li&gt;Server：告诉浏览器，服务器的类型 &lt;/li&gt;
&lt;li&gt;Content-Encoding: 服务器通过这个头，告诉浏览器，回送的数据采用的压缩格式。 &lt;/li&gt;
&lt;li&gt;Content-Length: 80 &lt;/li&gt;
&lt;li&gt;Content-Language: zh-cn &lt;/li&gt;
&lt;li&gt;Content-Type：这个头用于告诉浏览器，回送数据的类型 &lt;/li&gt;
&lt;li&gt;Last-Modified：这个头用于告诉浏览器，数据的最后修改时间 &lt;/li&gt;
&lt;li&gt;Refresh: ：这个头用于控制浏览器定时刷新 &lt;/li&gt;
&lt;li&gt;Content-Disposition: 用于通知浏览器，以下载方式打开回送的数据 &lt;/li&gt;
&lt;li&gt;Transfer-Encoding: 用于通知浏览器，数据是以分块形式回送的 &lt;/li&gt;
&lt;li&gt;ETag: 缓存相头的头 &lt;/li&gt;
&lt;li&gt;Expires: 用于说明网页的失效时间，如果该值为一个&lt;code&gt;&amp;lt;0&lt;/code&gt;的值，则服务器是通知浏览器不要缓存 &lt;/li&gt;
&lt;li&gt;Cache-Control: no-cache  通知浏览器不要缓存 &lt;/li&gt;
&lt;li&gt;Pragma: no-cache&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面只是简单介绍了下,如需详细还需要查阅手册.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://t.cn/R7FguRq&quot;&gt;HTTP权威指南&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;wireshark抓包查看HTTP过程&lt;/h3&gt;

&lt;p&gt;下面是打开&lt;code&gt;www.baidu.com&lt;/code&gt;所有的包:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;No.     Time           Source                Destination           Protocol Length Info
    355 4.170229000    222.26.7.125          119.75.217.56         TCP      74     50536 &amp;gt; http [SYN] Seq=0 Win=29200 Len=0 MSS=1460 SACK_PERM=1 TSval=7178795 TSecr=0 WS=128
    356 4.183233000    119.75.217.56         222.26.7.125          TCP      74     http &amp;gt; 50536 [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0 MSS=1440 SACK_PERM=1 WS=128
    357 4.183284000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=1 Ack=1 Win=29312 Len=0
    358 4.183343000    222.26.7.125          119.75.217.56         HTTP     131    GET / HTTP/1.1 
    359 4.196633000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [ACK] Seq=1 Ack=78 Win=24704 Len=0
    360 4.199425000    119.75.217.56         222.26.7.125          TCP      943    [TCP segment of a reassembled PDU]
    361 4.199454000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=890 Win=32128 Len=0
    362 4.199635000    119.75.217.56         222.26.7.125          TCP      1494   [TCP segment of a reassembled PDU]
    363 4.199652000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=2330 Win=35072 Len=0
    364 4.199766000    119.75.217.56         222.26.7.125          TCP      1494   [TCP segment of a reassembled PDU]

...

    475 4.217795000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=82970 Win=184192 Len=0
    476 4.217832000    119.75.217.56         222.26.7.125          HTTP     556    HTTP/1.1 200 OK  (text/html)
    477 4.217835000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=78 Ack=83472 Win=183808 Len=0
    478 4.218827000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [FIN, ACK] Seq=78 Ack=83472 Win=185856 Len=0
    479 4.232403000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [ACK] Seq=83472 Ack=79 Win=24704 Len=0
    480 4.232442000    119.75.217.56         222.26.7.125          TCP      60     http &amp;gt; 50536 [FIN, ACK] Seq=83472 Ack=79 Win=24704 Len=0
    481 4.232468000    222.26.7.125          119.75.217.56         TCP      54     50536 &amp;gt; http [ACK] Seq=79 Ack=83473 Win=185856 Len=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以清楚的看到HTTP的详细过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;355,356,357是三次握手的过程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后浏览器发送HTTP请求,其实这次请求是夹在第三次握手的包中的,可以看到HTTP包的详细信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Transmission Control Protocol, Src Port: 50536 (50536), Dst Port: http (80), Seq: 1, Ack: 1, Len: 77
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的seq=1,所以它是来自上一个TCP包.因为HTTP是由TCP包包装成的,所以这里显示的HTTP包其实是前面的TCP包的解包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来是一连串由服务器发来的TCP包和浏览器确认TCP包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直到476浏览器请求的所有TCP包都被接受,这时TCP按照序号把所有TCP包拆解并组成HTTP包.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;478~481最后4个为4次挥手.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/CareySon/archive/2012/04/27/HTTP-Protocol.html&quot;&gt;http://www.cnblogs.com/CareySon/archive/2012/04/27/HTTP-Protocol.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.360doc.com/content/10/0930/17/3668821_57590979.shtml&quot;&gt;http://www.360doc.com/content/10/0930/17/3668821_57590979.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/linzheng/archive/2011/01/25/1944914.html&quot;&gt;http://www.cnblogs.com/linzheng/archive/2011/01/25/1944914.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>TCP三次握手和四次挥手</title>
        <link href="http://hackerxu.com/2014/11/16/TCP.html"/>
        <updated>2014-11-16T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/16/TCP</id>
        <content type="html">&lt;p&gt;上周终于面了知乎,结果跪了~一是基础还不怎么扎实,二是没有准备,原以为能在12月分面试呢,结果发完题过两天就发了面试通知,不过知乎的态度真的不错,面了一个半点,虽然大多数问的问题都能知道,但是平时都没深入了解,所以今天总结一下TCP协议.&lt;/p&gt;

&lt;h2&gt;TCP图示&lt;/h2&gt;

&lt;p&gt;TCP(Transmission Control Protocol)传输控制协议.&lt;/p&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/ae52f886642e0019fa0973268eeb08b4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;TCP状态&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/375102e721925d18e6ac4e994a5ace8f.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面图中白色部分是TCP协议的字段,可以看到TCP的flag有6个,着重介绍下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;URG:紧急URG,当URG置为1时,发送应用进程就告诉发送方的TCO有紧急数据发送,于是发送方TCP就把紧急数据插入到&lt;strong&gt;本报文段数据的最前面&lt;/strong&gt;.*(例如用户从键盘发出中断命令,如果不使用紧急数据那么这个命令就会放在TCO的缓存末尾,这样浪费很多时间)&lt;/li&gt;
&lt;li&gt;ACK:当ACK=1时&lt;code&gt;Acknowledgment Number&lt;/code&gt;才有效.(仅在三次握手第一次握手时ACK=0,其他时刻ACK都为1)&lt;/li&gt;
&lt;li&gt;PSH:操作很少用到,当接受方TCP接受到PSH=1的报文段,就尽快的PUSH给接收应用进程,而不再等待整个缓存都填满后再向上交付.&lt;/li&gt;
&lt;li&gt;RST:当RST=1时说明发生了严重错误,必须释放连接,然后重新建立运输连接.&lt;/li&gt;
&lt;li&gt;SYN:连接建立时的同步信号,后面会说.&lt;/li&gt;
&lt;li&gt;FIN:释放连接,后面会说.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;三次握手&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次握手:
客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327002911.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二次握手:
服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003054.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三次握手.
客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/100327003214.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以在wireshark上看一下包的传递,下面以解析百度首页为例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2010:38:22%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以清楚的看到前三个包就是三次握手的TCP包,所有包中有用信息都在info里,再来解释下其他字段含义:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Win:窗口字段明确指出&lt;strong&gt;现在&lt;/strong&gt;允许&lt;strong&gt;对方&lt;/strong&gt;发送的数据量(经常变化)&lt;/li&gt;
&lt;li&gt;Len:暂时未知,TCP字段未有这个关键字?&lt;/li&gt;
&lt;li&gt;MSS(Maximum Segment Size):最大报文段长度,即每个TCP报文段中的数据字段的最大长度.这里需要在握手的时候进行协商,双方都给出MSS,最后以最小MSS确定为最终的MSS.IP数据报最大传输单位为MTU(Maximum Transmission Unit，Effect of short board),对于大多数使用以太网的局域网来说，MTU=1500。MSS往往基于MTU计算出来，通常MSS=MTU-sizeof(IP Header)-sizeof(TCP Header)=1500-20-20=1460,这里我们看到服务器MSS=1460,而客户端的MSS=1440,所以最终为1440.&lt;/li&gt;
&lt;li&gt;SACK_PERM:选择确认字段,如果中间缺少包而其他包都已经接收,那么直接传送缺少包.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三次握手和其他数据传输包没有区别,原因是这个包是为了改变服务器状态,使服务器从半连接状态转换为全连接状态.&lt;/p&gt;

&lt;h2&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/u=220219588,1869709485&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。&lt;/li&gt;
&lt;li&gt;服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。&lt;/li&gt;
&lt;li&gt;服务器B关闭与客户端A的连接，发送一个FIN给客户端A。&lt;/li&gt;
&lt;li&gt;客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在来看看百度的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/2014-11-16%2011:54:51%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;其实第2,4部和普通的数据传输包没有区别,关键是第1,3个FIN包,它们告诉对方自己将不传送信息,只接受信息.所以TCP的四次挥手可以看成是&lt;strong&gt;两个二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;为什么采用3次握手而不是2次握手?&lt;/h4&gt;

&lt;p&gt;如果两次握手的话,客户端有可能因为网络阻塞等原因会发送多个请求报文,这时服务器就会建立连接,浪费掉许多服务器的资源.&lt;/p&gt;

&lt;h4&gt;为什么建立连接是三次握手，而关闭连接却是四次挥手呢？&lt;/h4&gt;

&lt;p&gt;这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。&lt;/p&gt;

&lt;h4&gt;为什么在四次挥手中A在TIME-WAIT状态必须等待2MSL的时间?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;为了保证A发送的最后一个ACK报文能到达B.&lt;/li&gt;
&lt;li&gt;防止&amp;quot;已失效的连接请求报文段&amp;quot;,2MSL过后网络中没有此次连接的报文,可以进行下一个连接.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后TCP有限状态机:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/39b9724c51eec0a4380d0ca5e44cb227.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cppblog.com/csolay/archive/2011/10/22/158859.aspx&quot;&gt;http://www.cppblog.com/csolay/archive/2011/10/22/158859.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-7411781-id-3812206.html&quot;&gt;http://blog.chinaunix.net/uid-7411781-id-3812206.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.2cto.com/net/201208/149347.html&quot;&gt;http://www.2cto.com/net/201208/149347.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>粒子群算法(转)</title>
        <link href="http://hackerxu.com/2014/11/14/PSO.html"/>
        <updated>2014-11-14T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/14/PSO</id>
        <content type="html">&lt;p&gt;本文整理自: &lt;a href=&quot;http://blog.csdn.net/niuyongjie/article/details/1569671&quot;&gt;http://blog.csdn.net/niuyongjie/article/details/1569671&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;粒子群算法简介&lt;/h1&gt;

&lt;h2&gt;1 粒子群算法的历史&lt;/h2&gt;

&lt;p&gt;粒子群算法源于复杂适应系统（Complex Adaptive System,CAS）。CAS理论于1994年正式提出，CAS中的成员称为主体。比如研究鸟群系统，每个鸟在这个系统中就称为主体。主体有适应性，它能够与环境及其他的主体进行交流，并且根据交流的过程“学习”或“积累经验”改变自身结构与行为。整个系统的演变或进化包括：新层次的产生（小鸟的出生）；分化和多样性的出现（鸟群中的鸟分成许多小的群）；新的主题的出现（鸟寻找食物过程中，不断发现新的食物）。&lt;/p&gt;

&lt;p&gt;所以CAS系统中的主体具有4个基本特点（这些特点是粒子群算法发展变化的依据）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，主体是主动的、活动的。&lt;/li&gt;
&lt;li&gt;主体与环境及其他主体是相互影响、相互作用的，这种影响是系统发展变化的主要动力。&lt;/li&gt;
&lt;li&gt;环境的影响是宏观的，主体之间的影响是微观的，宏观与微观要有机结合。&lt;/li&gt;
&lt;li&gt;最后，整个系统可能还要受一些随机因素的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粒子群算法就是对一个CAS系统－－－鸟群社会系统的研究得出的。&lt;/p&gt;

&lt;p&gt;粒子群算法（ Particle Swarm Optimization, PSO）最早是由Eberhart和Kennedy于1995年提出，它的基本概念源于对鸟群觅食行为的研究。设想这样一个场景:一群鸟在随机搜寻食物，在这个区域里只有一块食物，所有的鸟都不知道食物在哪里，但是它们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢?最简单有效的就是搜寻目前离食物最近的鸟的周围区域。&lt;/p&gt;

&lt;p&gt;PSO算法就从这种生物种群行为特性中得到启发并用于求解优化问题。在PSO中，每个优化问题的潜在解都可以想象成d维搜索空间上的一个点，我们称之为“粒子”（Particle），所有的粒子都有一个被目标函数决定的适应值(Fitness Value )，每个粒子还有一个速度决定他们飞翔的方向和距离，然后粒子们就追随当前的最优粒子在解空间中搜索。Reynolds对鸟群飞行的研究发现。鸟仅仅是追踪它有限数量的邻居但最终的整体结果是整个鸟群好像在一个中心的控制之下.即复杂的全局行为是由简单规则的相互作用引起的。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的具体表述&lt;/h2&gt;

&lt;p&gt;上面罗嗦了半天，那些都是科研工作者写论文的语气，不过，PSO的历史就像上面说的那样。下面通俗的解释PSO算法。&lt;/p&gt;

&lt;p&gt;PSO算法就是模拟一群鸟寻找食物的过程，每个鸟就是PSO中的粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，不停改变自己在空中飞行的位置与速度。大家也可以观察一下，鸟群在寻找食物的过程中，开始鸟群比较分散，逐渐这些鸟就会聚成一群，这个群忽高忽低、忽左忽右，直到最后找到食物。这个过程我们转化为一个数学问题。寻找函数&lt;code&gt;y=1-cos(3*x)*exp(-x)&lt;/code&gt;的在[0,4]最大值。该函数的图形如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_hanshutuxing.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;当x=0.9350-0.9450，达到最大值y=1.3706。为了得到该函数的最大值，我们在[0，4]之间随机的洒一些点，为了演示，我们放置两个点，并且计算这两个点的函数值，同时给这两个点设置在[0，4]之间的一个速度。下面这些点就会按照一定的公式更改自己的位置，到达新位置后，再计算这两个点的值，然后再按照一定的公式更新自己的位置。直到最后在y=1.3706这个点停止自己的更新。这个过程与粒子群算法作为对照如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这两个点就是粒子群算法中的粒子。&lt;/li&gt;
&lt;li&gt;该函数的最大值就是鸟群中的食物 &lt;/li&gt;
&lt;li&gt;计算两个点函数值就是粒子群算法中的适应值，计算用的函数就是粒子群算法中的适应度函数。&lt;/li&gt;
&lt;li&gt;更新自己位置的一定公式就是粒子群算法中的位置速度更新公式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面演示一下这个算法运行一次的大概过程：&lt;/p&gt;

&lt;p&gt;第一次初始化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi1.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi2.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二次更新位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi3.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第21次更新:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi4.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后的结果（30次迭代）:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_yanshi5.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;最后所有的点都集中在最大值的地方。&lt;/p&gt;

&lt;p&gt;呵呵，现在粒子群算法的大概思想就说到这里。下节介绍标准的粒子群算法.&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法&lt;/h1&gt;

&lt;p&gt;在上一节的叙述中，唯一没有给大家介绍的就是函数的这些随机的点（粒子）是如何运动的，只是说按照一定的公式更新。这个公式就是粒子群算法中的位置速度更新公式。下面就介绍这个公式是什么。在上一节中我们求取函数y=1-cos(3*x)*exp(-x)的在[0,4]最大值。并在[0,4]之间放置了两个随机的点，这些点的坐标假设为$x_1=1.5$；$ x_2=2.5$；这里的点是一个标量，但是我们经常遇到的问题可能是更一般的情况－－x为一个矢量的情况，比如二维的情$况 z=2*x_1+3*x_2$的情况。这个时候我们的每个粒子为二维，记粒$子P_1＝(x_{11},x_{12}),P2=(x_{21},x_{22}),P3=(x_{31},x_{32})，......Pn=(x_{n1},x_{n2})$。这里n为粒子群群体的规模，也就是这个群中粒子的个数，每个粒子的维数为2。更一般的是粒子的维数为q，这样在这个种群中有n个粒子，每个粒子为q 维。&lt;/p&gt;

&lt;p&gt;由n个粒子组成的群体对Q维（就是每个粒子的维数）空间进行搜索。每个粒子表示为：$xi＝（x_{i1},x_{i2},x_{i3},...,x_{iQ}）$，每个粒子对应的速度可以表示为$vi=(v_{i1},v_{i2},v_{i3},....,v_{iQ})$，每个粒子在搜索时要考虑两个因素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自己搜索到的历史最优值 $p_i ，p_i=(p_{i1},p_{i2},....,p_{iQ})$，i=1,2,3,....,n。&lt;/li&gt;
&lt;li&gt;全部粒子搜索到的最优值$p_g，p_g=(p_{g1},p_{g2},....,p_{gQ})$，注意这里的$p_g$只有一个。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面给出粒子群算法的位置速度更新公式：&lt;/p&gt;

&lt;p&gt;$$v_{id}^{k+1} = wv_{id}^{k} + c_1\xi(p_{id}^k - x_{id}^k) + c_2\eta(p_{gd}^{k} - x_{id}^k)$$&lt;/p&gt;

&lt;p&gt;$$x_{id}^{k+1} = x_{id}^{k} + rv_{id}^{k+1}$$&lt;/p&gt;

&lt;p&gt;这里有几个重要的参数需要大家记忆，因为在以后的讲解中将会经常用到,它们是：&lt;/p&gt;

&lt;p&gt;$w$是保持原来速度的系数，所以叫做&lt;strong&gt;惯性权重&lt;/strong&gt;。
$c_1$是粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，所以叫“&lt;strong&gt;认知&lt;/strong&gt;”。通常设置为2。
$\xi$  $\eta$是[0,1]区间内均匀分布的随机数。
$r$是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做&lt;strong&gt;约束因子&lt;/strong&gt;。通常设置为1。&lt;/p&gt;

&lt;p&gt;这样一个标准的粒子群算法就结束了。&lt;/p&gt;

&lt;p&gt;下面对整个基本的粒子群的过程给一个简单的图形表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_liucheng.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;判断终止条件可是设置适应值到达一定的数值或者循环一定的次数。&lt;/p&gt;

&lt;p&gt;注意：这里的粒子是同时跟踪自己的历史最优值与全局（群体）最优值来改变自己的位置预速度的，所以又叫做&lt;strong&gt;全局版本的标准粒子群优化算法&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;标准的粒子群算法(局部版本)&lt;/h1&gt;

&lt;p&gt;在全局版的标准粒子群算法中，每个粒子的速度的更新是根据两个因素来变化的，这两个因素是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子群体的全局最优值$p_g$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果改变粒子速度更新公式，让每个粒子的速度的更新根据以下两个因素更新，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子自己历史最优值$p_i$。&lt;/li&gt;
&lt;li&gt;粒子&lt;strong&gt;邻域内&lt;/strong&gt;粒子的最优值$pn_k$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其余保持跟全局版的标准粒子群算法一样，这个算法就变为局部版的粒子群算法。&lt;/p&gt;

&lt;p&gt;一般一个粒子i 的邻域随着迭代次数的增加而逐渐增加，开始第一次迭代，它的邻域为0，随着迭代次数邻域线性变大，最后邻域扩展到整个粒子群，这时就变成全局版本的粒子群算法了。经过实践证明：全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在&lt;strong&gt;收敛速度与摆脱局部最优&lt;/strong&gt;这两个方面下功夫。其实这两个方面是矛盾的。看如何更好的折中了。&lt;/p&gt;

&lt;p&gt;根据取邻域的方式的不同，局部版本的粒子群算法有很多不同的实现方法.&lt;/p&gt;

&lt;p&gt;第一种方法：按照粒子的编号取粒子的邻域，取法有四种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;环形取法 &lt;/li&gt;
&lt;li&gt;随机环形取法 &lt;/li&gt;
&lt;li&gt;轮形取法 &lt;/li&gt;
&lt;li&gt;随机轮形取法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/o_huan.bmp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;因为后面有以环形取法实现的算法，对环形取法在这里做一点点说明：以粒子1为例，当邻域是0的时候，邻域是它本身，当邻域是1时，邻域为2，8；当邻域是2时，邻域是2，3，7，8；......，以此类推，一直到邻域为4，这个时候，邻域扩展到整个例子群体。据文献介绍（&lt;strong&gt;国外的文献&lt;/strong&gt;），采用轮形拓扑结构，PSO的效果很好。&lt;/p&gt;

&lt;p&gt;第二种方法：按照粒子的欧式距离取粒子的邻域&lt;/p&gt;

&lt;p&gt;在第一种方法中，按照粒子的编号来得到粒子的邻域，但是这些粒子其实可能在实际位置上并不相邻，于是Suganthan提出基于空间距离的划分方案，在迭代中计算每一个粒子与群中其他粒子的距离。记录任何2个粒子间的的最大距离为dm。对每一粒子按照$||x_a-x_b||/dm$计算一个比值。其中||xa-xb||是当前粒子a到b的距离。而选择阈值frac根据迭代次数而变化。当另一粒子b满足$||x_a-x_b||/dm &amp;lt; frac$时，认为b成为当前粒子的邻域。&lt;/p&gt;

&lt;p&gt;这种办法经过实验，取得较好的应用效果，但是由于要计算所有粒子之间的距离，计算量大，且需要很大的存储空间，所以，&lt;strong&gt;该方法一般不经常使用&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;粒子群算法分类&lt;/h1&gt;

&lt;p&gt;粒子群算法主要分为4个大的分支：&lt;/p&gt;

&lt;h2&gt;1 标准粒子群算法的变形&lt;/h2&gt;

&lt;p&gt;在这个分支中，主要是对标准粒子群算法的惯性因子、收敛因子（约束因子）、“认知”部分的$c_1$，“社会”部分的$c_2$进行变化与调节，希望获得好的效果。&lt;/p&gt;

&lt;p&gt;惯性因子的原始版本是保持不变的，后来有人提出随着算法迭代的进行，惯性因子需要逐渐减小的思想。算法开始阶段，大的惯性因子可以使算法不容易陷入局部最优，到算法的后期，小的惯性因子可以使收敛速度加快，使收敛更加平稳，不至于出现振荡现象。&lt;strong&gt;经过本人测试&lt;/strong&gt;，动态的减小惯性因子w，的确可以使算法更加稳定，效果比较好。但是递减惯性因子采用什么样的方法呢？人们首先想到的是线型递减，这种策略的确很好，但是是不是最优的呢？于是有人对递减的策略作了研究，研究结果指出：线型函数的递减优于凸函数的递减策略，但是凹函数的递减策略又优于线型的递减，经过本人测试，实验结果基本符合这个结论，但是效果不是很明显。&lt;/p&gt;

&lt;p&gt;对于收敛因子，经过证明如果收敛因子取0.729,可以确保算法的收敛，但是不能保证算法收敛到全局最优，经过本人测试，取收敛因子为0.729效果较好。对于社会与认知的系数$c_1$,$c_2$也有人提出：$c_1$先大后小，而$c_2$先小后大的思想，因为在算法运行初期，每个鸟要有大的自己的认知部分而又比较小的社会部分，这个与我们自己一群人找东西的情形比较接近，因为在我们找东西的初期，我们基本依靠自己的知识取寻找，而后来，我们积累的经验越来越丰富，于是大家开始逐渐达成共识（社会知识），这样我们就开始依靠社会知识来寻找东西了。&lt;/p&gt;

&lt;p&gt;2007年希腊的两位学者提出将收敛速度比较快的全局版本的粒子群算法与不容易陷入局部最优的局部版本的粒子群算法相结合的办法，利用的公式是:&lt;/p&gt;

&lt;p&gt;速度更新公式，v代表速度&lt;/p&gt;

&lt;p&gt;$$ v＝n*v(全局版本)＋（1－n）*v(局部版本) $$&lt;/p&gt;

&lt;p&gt;位置更新公式&lt;/p&gt;

&lt;p&gt;$$w（k＋1）＝w(k)＋v$$&lt;/p&gt;

&lt;p&gt;该算法在文献中讨论了系数n取各种不同情况的情况，并且运行来了20000次来分析各种系数的结果。&lt;/p&gt;

&lt;h2&gt;2 粒子群算法的混合&lt;/h2&gt;

&lt;p&gt;这个分支主要是将粒子群算法与各种算法相混合，有人将它与模拟退火算法相混合，有些人将它与单纯形方法相混合。但是最多的是将它与遗传算法的混合。根据遗传算法的三种不同算子可以生成3中不同的混合算法。&lt;/p&gt;

&lt;h3&gt;粒子群算法与选择算子的结合&lt;/h3&gt;

&lt;p&gt;这里相混合的思想是：在原来的粒子群算法中，我们选择粒子群群体的最优值作为$p_g$，但是相结合的版本是根据所有粒子的适应度的大小给每个粒子赋予一个被选中的概率，然后依据概率对这些粒子进行选择，被选中的粒子作为$p_g$，其它的情况都不变。这样的算法可以在算法运行过程中保持粒子群的多样性，但是致命的缺点是收敛速度缓慢。&lt;/p&gt;

&lt;h3&gt;粒子群算法与杂交算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想与遗传算法的基本一样，在算法运行过程中根据适应度的大小，粒子之间可以两两杂交，比如用一个很简单的公式:&lt;/p&gt;

&lt;p&gt;$$w（新）＝n×w_1＋（1－n）×w_2$$&lt;/p&gt;

&lt;p&gt;w1与w2就是这个新粒子的父辈粒子。&lt;/p&gt;

&lt;p&gt;这种算法可以在算法的运行过程中引入新的粒子，但是算法一旦陷入局部最优，那么粒子群算法将很难摆脱局部最优。&lt;/p&gt;

&lt;h3&gt;粒子群算法与变异算子的结合&lt;/h3&gt;

&lt;p&gt;结合的思想：测试所有粒子与当前最优的距离，当距离小于一定的数值的时候，可以拿出所有粒子的一个百分比（如10％）的粒子进行随机初始化，让这些粒子重新寻找最优值。&lt;/p&gt;

&lt;h2&gt;3 二进制粒子群算法&lt;/h2&gt;

&lt;p&gt;最初的PSO是从解决连续优化问题发展起来的.Eberhart等又提出了PSO的离散二进制版.用来解决工程实际中的组合优化问题。他们在提出的模型中将粒子的每一维及粒子本身的历史最优、全局最优限制为1或0，而速度不作这种限制。用速度更新位置时，设定一个阈值，当速度高于该阈值时，粒子的位置取1，否则取0。二进制PSO与遗传算法在形式上很相似，但实验结果显示，在大多数测试函数中，二进制PSO比遗传算法速度快，尤其在问题的维数增加时.&lt;/p&gt;

&lt;h2&gt;4 协同粒子群算法&lt;/h2&gt;

&lt;p&gt;协同PSO，该方法将粒子的D维分到D个粒子群中，每个粒子群优化一维向量，评价适应度时将这些分量合并为一个完整的向量。例如第i个粒子群，除第i个分量外，其他D-1个分量都设为最优值，不断用第i个粒子群中的粒子替换第i个分量，直到得到第i维的最优值，其他维相同。为将有联系的分量划分在一个群，可将D维向量分配到m个粒子群优化，则前D mod m个粒子群的维数是D/m的向上取整。后m－(D mod m)个粒子群的维数是D/m的向下取整。协同PSO在某些问题上有更快的收敛速度，但该算法容易被欺骗。&lt;/p&gt;

&lt;p&gt;基本的粒子群算法的分支就着4个，大部分的粒子群算法都围绕着这4个分支在变化，其中粒子群算法的变形居多，从根本上来说，几乎没有什么新的思想的提出。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>协程</title>
        <link href="http://hackerxu.com/2014/11/08/Coroutine.html"/>
        <updated>2014-11-08T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/08/Coroutine</id>
        <content type="html">&lt;p&gt;知乎上的&lt;a href=&quot;http://www.zhihu.com/question/20511233&quot;&gt;这个&lt;/a&gt;答案很好,总结一下协程.&lt;/p&gt;

&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;

&lt;h2&gt;进程、线程和协程&lt;/h2&gt;

&lt;p&gt;进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。&lt;/p&gt;

&lt;p&gt;线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。&lt;/p&gt;

&lt;p&gt;协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;共享堆&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;共享栈&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;操作系统调度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;进程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;线程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;协程&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h4&gt;与进程&amp;amp;线程的不同之处&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;操作系统内核不知道协程的存在&lt;/li&gt;
&lt;li&gt;协程不独享进程控制块和处理机时间片&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;与进程&amp;amp;线程的相同之处&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;协程的状态存在挂起、唤醒、死亡&lt;/li&gt;
&lt;li&gt;协程和协程之前有控制权的释放和获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。&lt;/p&gt;

&lt;h2&gt;协程的优势&lt;/h2&gt;

&lt;p&gt;最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。&lt;/p&gt;

&lt;p&gt;第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。&lt;/p&gt;

&lt;h2&gt;Python中的协程&lt;/h2&gt;

&lt;p&gt;一个实际一点的例子：thread.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python thread.py&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python -m gevent.monkey thread.py&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;threadA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threadB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;threadA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threadB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python thread.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你是均匀输出的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A
B
A
B
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么总共发生了 20 次切换：主线程 -&amp;gt; A -&amp;gt; B -&amp;gt; A -&amp;gt; B …&lt;/p&gt;

&lt;p&gt;再看一个协程的例子：gr.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# python gr.py&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextGreenlets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;greenletA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;greenletB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;greenletA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greenletB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;greenlet 是 python 的协程实现。&lt;/p&gt;

&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python gr.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时发生了 2 次切换：主协程 -&amp;gt; A -&amp;gt; B&lt;/p&gt;

&lt;p&gt;可能你已经注意到了，还有一个命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python -m gevent.monkey thread.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gevent 是基于 greenlet 的一个 python 库，它可以把 python 的内置线程用 greenlet 包装，这样在我们使用线程的时候，实际上使用的是协程，在上一个协程的例子里，协程 A 结束时，由协程 A 让位给协程 B ，而在 gevent 里，所有需要让位的协程都让位给主协程，由主协程决定运行哪一个协程，gevent 也会包装一些可能需要阻塞的方法，比如 sleep ，比如读 socket ，比如等待锁，等等，在这些方法里会自动让位给主协程，而不是由程序员显示让位，这样程序员就可以按照线程的模式进行线性编程，不需要考虑切换的逻辑。&lt;/p&gt;

&lt;p&gt;假设代码质量相同，用原生的协程实现需要切换 n 次，用协程包装后的线程实现，就需要 2n - 1 次，姑且算是两倍吧。很显然，单纯从效率上来说，代码质量相同的前提下，用 gevent 永远也不可能比用 greenlet 快，然而，问题往往不那么单纯，比方说，单纯从效率上来说，代码质量相同的前提下，用 C 实现的程序永远不可能比汇编快。&lt;/p&gt;

&lt;p&gt;再来说说 python 的线程，python 的线程不是标准线程，在 python 中，一个进程内的多个线程只能使用一个 CPU 。&lt;/p&gt;

&lt;p&gt;重新来看一下协程和线程的区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。&lt;/p&gt;

&lt;p&gt;如果使用 gevent 包装后的线程，程序员就不必承担调度的责任，而 python 的线程本身就没有使用多 CPU 的能力，那么，用 gevent 包装后的线程，取代 python 的内置线程，不是只有避免无意义的调度，提高性能的好处，而没有什么坏处了吗？&lt;/p&gt;

&lt;p&gt;答案是否定的。举一个例子，有一个 GUI 程序，上面有两个按钮，一个 运算 一个 取消 ，点击运算，会有一个运算线程启动，不停的运算，点击取消，会取消这个线程，如果使用 python 的内置线程或者标准线程，都是没有问题的，即便运算线程不停的运算，调度器仍然会给 GUI 线程分配时间片，用户可以点击取消，然而，如果使用 gevent 包装后的线程就完蛋了，一旦运算开始，GUI 就会失去相应，因为那个运算线程(协程)霸着 CPU 不让位。不单是 GUI ，所有和用户交互的程序都会有这个问题。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tonyseek/introduce-to-coroutine/blob/master/docs/source/index.rst&quot;&gt;https://github.com/tonyseek/introduce-to-coroutine/blob/master/docs/source/index.rst&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000&quot;&gt;http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20511233&quot;&gt;http://www.zhihu.com/question/20511233&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>One Piece</title>
        <link href="http://hackerxu.com/2014/11/05/OnePiece.html"/>
        <updated>2014-11-05T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/11/05/OnePiece</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/7702.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;我是要成为海贼王的男人.&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>草帽星系</title>
        <link href="http://hackerxu.com/2014/10/26/habo.html"/>
        <updated>2014-10-26T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/26/habo</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/900x600_A9FVD2A84T8F0001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;渺小的人类&lt;/p&gt;
</content>
    </entry>
    
    <entry>
        <title>数据挖掘之Apriori算法</title>
        <link href="http://hackerxu.com/2014/10/18/apriori.html"/>
        <updated>2014-10-18T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/18/apriori</id>
        <content type="html">&lt;p&gt;关联规则挖掘（Association rule mining）是数据挖掘中最活跃的研究方法之一，可以用来发现事情之间的联系，最早是为了发现超市交易数据库中不同的商品之间的关系。(啤酒与尿布)&lt;/p&gt;

&lt;h4&gt;基本概念&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;支持度的定义：support(X--&amp;gt;Y) = |X交Y|/N=集合X与集合Y中的项在一条记录中同时出现的次数/数据记录的个数。例如：support({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/数据记录数 = 3/5=60%。&lt;/li&gt;
&lt;li&gt;自信度的定义：confidence(X--&amp;gt;Y) = |X交Y|/|X| = 集合X与集合Y中的项在一条记录中同时出现的次数/集合X出现的个数 。例如：confidence({啤酒}--&amp;gt;{尿布}) = 啤酒和尿布同时出现的次数/啤酒出现的次数=3/3=100%;confidence({尿布}--&amp;gt;{啤酒}) = 啤酒和尿布同时出现的次数/尿布出现的次数 = 3/4 = 75%&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作&lt;strong&gt;强规则&lt;/strong&gt; ,如果项集满足最小支持度,则称它为&lt;strong&gt;频繁项集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“如何由大型数据库挖掘关联规则?”关联规则的挖掘是一个两步的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找出所有频繁项集:根据定义,这些项集出现的频繁性至少和预定义的最小支持计数一样。&lt;/li&gt;
&lt;li&gt;由频繁项集产生强关联规则:根据定义,这些规则必须满足最小支持度和最小置信度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apriori定律&lt;/p&gt;

&lt;p&gt;为了减少频繁项集的生成时间，我们应该尽早的消除一些完全不可能是频繁项集的集合，Apriori的两条定律就是干这事的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律1&lt;/strong&gt;：如果一个集合是频繁项集，则它的所有子集都是频繁项集。举例：假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apriori定律2&lt;/strong&gt;：如果一个集合不是频繁项集，则它的所有超集都不是频繁项集。举例：假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/taizilongxu.github.io/master/img/31160727-a7d9a4d0a64a4f4b83a831980273450d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;上面的图演示了Apriori算法的过程，注意看由二级频繁项集生成三级候选项集时，没有{牛奶,面包,啤酒}，那是因为{面包,啤酒}不是二级频繁项集，这里利用了Apriori定理。最后生成三级频繁项集后，没有更高一级的候选项集，因此整个算法结束，{牛奶,面包,尿布}是最大频繁子集。&lt;/p&gt;

&lt;p&gt;Python实现算法地址&lt;a href=&quot;https://github.com/taizilongxu/datamining&quot;&gt;https://github.com/taizilongxu/datamining&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&quot;&gt;http://www.cnblogs.com/fengfenggirl/p/associate_apriori.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lizhengnanhua/article/details/9061887&quot;&gt;http://blog.csdn.net/lizhengnanhua/article/details/9061887&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
        <title>Python subprocess模块总结</title>
        <link href="http://hackerxu.com/2014/10/09/subprocess.html"/>
        <updated>2014-10-09T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/09/subprocess</id>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;subprocess意在替代其他几个老的模块或者函数，比如：os.system os.spawn* os.popen* popen2.* commands.*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;subprocess最简单的用法就是调用shell命令了,另外也可以调用程序,并且可以通过stdout,stdin和stderr进行交互&lt;/p&gt;

&lt;h4&gt;subprocess的主类&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;bufsize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;executable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;preexec_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;close_fds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;universal_newlines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;startupinfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;creationflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;args可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。&lt;/li&gt;
&lt;li&gt;bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲)&lt;/li&gt;
&lt;li&gt;stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。&lt;/li&gt;
&lt;li&gt;preexec_fn只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。&lt;/li&gt;
&lt;li&gt;Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。&lt;/li&gt;
&lt;li&gt;shell设为true，程序将通过shell来执行。&lt;/li&gt;
&lt;li&gt;cwd用于设置子进程的当前目录&lt;/li&gt;
&lt;li&gt;env是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。&lt;/li&gt;
&lt;li&gt;Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用&amp;#39;/r/n&amp;#39;表示换，而Linux下用&amp;#39;/n&amp;#39;。如果将此参数设置为True，Python统一把这些换行符当作&amp;#39;/n&amp;#39;来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;li&gt;startupinfo与createionflags只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Popen方法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Popen.poll()：用于检查子进程是否已经结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.wait()：等待子进程结束。设置并返回returncode属性。&lt;/li&gt;
&lt;li&gt;Popen.communicate(input=None)：与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。&lt;/li&gt;
&lt;li&gt;Popen.send_signal(signal)：向子进程发送信号。&lt;/li&gt;
&lt;li&gt;Popen.terminate()：停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。&lt;/li&gt;
&lt;li&gt;Popen.kill()：杀死子进程。&lt;/li&gt;
&lt;li&gt;Popen.stdin：如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stdout：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.stderr：如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回None。&lt;/li&gt;
&lt;li&gt;Popen.pid：获取子进程的进程ID。&lt;/li&gt;
&lt;li&gt;Popen.returncode：获取进程的返回值。如果进程还没有结束，返回None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;：运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。文章一开始的例子就演示了call函数。如果子进程不需要进行交互,就可以使用该函数来创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subprocess.check_call(*popenargs, **kwargs)&lt;/code&gt;：与&lt;code&gt;subprocess.call(*popenargs, **kwargs)&lt;/code&gt;功能一样，只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常。在异常对象中，包括进程的returncode信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上全是抄的&lt;/p&gt;

&lt;h4&gt;在程序中运行其他程序或shell&lt;/h4&gt;

&lt;p&gt;可以这样写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;subprocess.call(&amp;#39;脚本/shell&amp;#39;, shell=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者的区别是前者无阻塞,会和主程序并行运行,后者必须等待命令执行完毕,如果想要前者编程阻塞可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;s = subprocess.Popen(&amp;#39;脚本/shell&amp;#39;, shell=True)
s.wait()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;程序返回运行结果&lt;/h4&gt;

&lt;p&gt;有时候我们需要程序的返回结果,可以这样做&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.Popen(&amp;#39;ls -l&amp;#39;, shell=True, stdout=subprocess.PIPE) 
&amp;gt;&amp;gt;&amp;gt; s.communicate() 
(&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;, None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会返回一个元组：(stdoutdata, stderrdata)&lt;/p&gt;

&lt;p&gt;subprocess还有另一种更简单方法,效果一样,它会返回stdout&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = subprocess.check_output(&amp;#39;ls -l&amp;#39;, shell=True)
&amp;gt;&amp;gt;&amp;gt; s
&amp;#39;\xe6\x80\xbb\xe7\x94\xa8\xe9\x87\x8f 152\n-rw------- 1 limbo limbo   808  7\xe6\x9c\x88  6 17:46 0000-00-00-welcome-to-jekyll.markdown.erb\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88 15 18:43 arg\ndrwx------ 2 limbo limbo  4096  8\xe6\x9c\x88  7 17:37 argv\ndrwxrwxr-x 2 limbo limbo  4096  9\xe6\x9c\x88 10 15:27 c\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9c\x88 11 14:35 d3\ndrwxrwxr-x 3 limbo limbo  4096  9\xe6\x9n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前者可以实现更多的交互,如stderr和stdin,但是在前面调用Popen的时候要实现定义&lt;code&gt;Popen(stdin=subprocess.PIPE, stderr=subprocess)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;给子进程输入&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;vamei&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;()不为空，则写入subprocess.PIPE，为空，则从subprocess.PIPE读取&lt;/p&gt;

&lt;h4&gt;subprocess.PIPE&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ls&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;-l&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wc&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;communicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上是这样的过程&lt;/p&gt;

&lt;p&gt;child1.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdin&amp;lt;--subprocess.PIPE&lt;/p&gt;

&lt;p&gt;child2.stdout--&amp;gt;subprocess.PIPE&lt;/p&gt;

&lt;p&gt;要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;subprocess.PIPE实际上为文本流提供一个缓存区。直到communicate()方法从PIPE中读取出PIPE中的文本.要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/jgood/article/details/4498166&quot;&gt;http://blog.csdn.net/jgood/article/details/4498166&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&quot;&gt;http://www.cnblogs.com/GODYCA/archive/2013/05/08/3066870.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/imzoer/article/details/8678029&quot;&gt;http://blog.csdn.net/imzoer/article/details/8678029&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ipseek.blog.51cto.com/1041109/807513&quot;&gt;http://ipseek.blog.51cto.com/1041109/807513&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jb51.net/article/48086.htm&quot;&gt;http://www.jb51.net/article/48086.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    </entry>
    
    <entry>
        <title>把程序打包上传到PyPi版本库中</title>
        <link href="http://hackerxu.com/2014/10/08/Pypi.html"/>
        <updated>2014-10-08T00:00:00+08:00</updated>
        <id>http://hackerxu.com/2014/10/08/Pypi</id>
        <content type="html">&lt;h4&gt;1 首先必须要按照以下文件结构&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;douban_token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;│  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;md&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;└──&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;必须至少一个包,即上面的douban,把模块都放在包下,且包中必须有&lt;code&gt;__init__.py&lt;/code&gt;文件(可以为空)&lt;/li&gt;
&lt;li&gt;必须有一个setup.py文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;2 setup.py文件&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#-*- encoding: UTF-8 -*-&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;setuptools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_packages&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;打包的用的setup必须引入&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;0.2.0&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;README.md&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 文件名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 版本(每次更新上传Pypi需要修改)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a tiny and smart cli player of douban.fm based on Python&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;long_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 放README.md文件,方便在Pypi页展示&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;classifiers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;keywords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;python douban douban.fm terminal&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关键字&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;taizilongxu&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 用户名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;468137306@qq.com&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 邮箱&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;https://github.com/taizilongxu/douban.fm&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# github上的地址,别的地址也可以&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;license&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;MIT&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 遵循的协议&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;douban&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 发布的包名&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;include_package_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;zip_safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;install_requires&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;termcolor&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 满足的依赖&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry_points&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;#39;console_scripts&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&amp;#39;douban.fm = douban.douban:main&amp;#39;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; entry_points : [可执行程序名]=引入的包名.子包名.模块名:入口函数.这个要注意了,主程序要引入main函数进行执行.好让包找到执行的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3 安装&lt;/h4&gt;

&lt;p&gt;如果不上传文件,只在本机中安装,那么可以运行以下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就在本机安装了程序,在shell中输入douban.fm(刚才在entry_points中输入的可执行程序名),就可以执行了&lt;/p&gt;

&lt;h4&gt;4 上传到Pypi&lt;/h4&gt;

&lt;p&gt;先在 &lt;a href=&quot;https://pypi.python.org/pypi&quot;&gt;https://pypi.python.org/pypi&lt;/a&gt; 注册个Pypi号,认证邮箱.&lt;/p&gt;

&lt;p&gt;然后再在你的用户目录下新建一个&lt;code&gt;.pypirc&lt;/code&gt;文件,输入如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[distutils]
index-servers =
    pypi

[pypi]
username:
password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把username和password填上保存就可以了&lt;/p&gt;

&lt;p&gt;回到你的setup.py目录,输入如下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo python setup.py register sdist bdist_egg upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你的包就可以发到Pypi里了,通过pip或者easy_install就可以下载你的包了&lt;/p&gt;

&lt;h4&gt;5 更新Pypi包&lt;/h4&gt;

&lt;p&gt;当包版本更新后,需要在你的setup.py文件里修改VERSION,然后运行第4部的命令就可以了(如果不更新VERSION包就不能上传成功)&lt;/p&gt;
</content>
    </entry>
    

</feed>
